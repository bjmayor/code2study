* 第一章 导言
在允许使用某种类型的变量值的任何场合，都可以使用该类型的更复杂的表达式。

在程序中使用300、20等"幻数"并不是好习惯，它们几乎不能给以后阅读程序的人提供什么信息，而且使程序的修改更加困难。处理这类幻数的一种方法是赋与它们有意义的名字。

#define 指令行的未尾没有分号。

标准库提供的输入/输出模型非常简单：无论文本从何处输入，输出到何处，其输入/输出都是按照字符流的方式处理。

语句++nc比nc=nc+1更精炼一些，且通常效率更高一些。

%.0f强制不打印小数点和后面的小数部分，因此小数部分的位数为0。

单独的分号称为空语句。

单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称之为字符常量。
但是，它只不过是小的整型数的另一种写法而已。

如果程序中的幻数都以符号常量的形式出现，对程序进行大量修改就会相对容易很多。

在兼有值与赋值两种功能的表达式中，赋值结合次序是由右至左。

char类型的字符是小整数，因此char类型的变量和常量在算术表达式中等价于int类型的变量和常量。

程序中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失，这也是其他语言通常把这类变量称为 *自动变量* 的原因。
如果 *自动变量* 没有赋值，则其中存放的是无效值。
 *外部变量* 必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。在每个需要访问外部变量的函数中，必须声明相应的外部变量，此时声明其类型。
声明时可以用 *extern*语句显示声明，也可以通过上下文隐式声明。
在源文件中，如果外部变量的定义出现在使用它的函数之前，那么在那个函数中就没有必要使用extern声明。
在通常的做法中，所有外部的变量的定义都是放在源文件中的开始处，这样就可以省略extern声明。
如果程序包含在多个源文件中，而某个变量在file1中定义，在file2和file3文件中使用，那么在文件file2与file3中就需要使用extern声明来建立该变量与其定义之间的联系。

"定义"表示创建变量或分配存储单元，而"声明"指的是说明变量的性质，但并不分配存储单元。

过分依赖外部变量会导致一定的风险，因为它会使程序中的数据关系模糊不清--外部变量的值可能会被意外地或不经意地修改，而程序的修改又变得十分困难。

* 第二章 类型、运算与表达式
  标准函数strlen(s)可以返回字符串参数s的长度，但长度不包括末尾的'\0'。

  枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于#define语句来说，它的优势在于常量值可以自动生成。

  所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。
  
  如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式。
  默认情况下，外部变量与静态变量将被初始化为0。未经显式初始化的自动变量的值为未定义的(即无效值)。
  
  对数组而言，const限定符指定数组所有元素的值都不能被修改。
  const限定符也可配合参数使用，它表明函数不能修改数组元素的值。
  如果试图修改const限定的值，其结果取决于具体的实现。
  
  逻辑非运算符!的作用是将非0操作数转换为0，将操作数0转换为1。
** 类型转换 
  一般来说，自动转换是指把"比较窄"操作数转换为"比较宽的"操作数，并且不丢失信息的转换。
  
  C语言没有指定char类型的变量是无符号变量还是有符号变量。
  C语言定义保证了机器的标准打印字符集中的字符不会是负值，因此，在表达式中这些字符总是正值。但在，存储在字符变量中的位模式在某些机器中可能是负的，
而在另一些机器中可能是正的。为了保证程序的可移植性，如果要在char类型的变量中存储非字符数据，最好指定signed或unsigned限定符。

 注意，表达式中的float类型的操作数不会自动转换为double类型，这一点与最初的定义有所不同。一般来说，数学函数使用double的变量。
使用float类型主要是为了在使用较大的数组时节省存储空间，有时也是为了节省机器执行时间(双精度算术运算特别费时)。

 带符号与无符号值之间的比较运算是与机器相关的，因为它们取决于不同整数类型的大小。譬如-1L<1U, -1L>1UL(-1L被转换成UL,转成了正数)
 
 当把较长的整数转换为较短的整数或char类型时，超出的高位部分将被丢弃。
 
 当被double类型转换为float类型时，是进行四舍五入还是截取取决于具体的实现。
 
 即使调用函数的参数是char或float类型，我们也把函数参数声明为int或double类型。
 
 通常情况下，参数是通过函数原型声明的。
 
 在对signed类型的带符号值进行右移时，某些机器将对左边空出的部分用符号位填补（即“算术移位”），而另一些机器则对左边空出来的部分用0填补（即“逻辑位移”）
 
 x = x & ~077
 注意，表达式x&~077与机器字长无关，它比形式为x&0177700的表达式要好，因为后者假定x是16位的数值。这种可移植的形式并没有增加额外开销，因为
 ~077是常量表达式，可以在编译时求值。