* 第一章 导言
在允许使用某种类型的变量值的任何场合，都可以使用该类型的更复杂的表达式。

在程序中使用300、20等"幻数"并不是好习惯，它们几乎不能给以后阅读程序的人提供什么信息，而且使程序的修改更加困难。处理这类幻数的一种方法是赋与它们有意义的名字。

#define 指令行的未尾没有分号。

标准库提供的输入/输出模型非常简单：无论文本从何处输入，输出到何处，其输入/输出都是按照字符流的方式处理。

语句++nc比nc=nc+1更精炼一些，且通常效率更高一些。

%.0f强制不打印小数点和后面的小数部分，因此小数部分的位数为0。

单独的分号称为空语句。

单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称之为字符常量。
但是，它只不过是小的整型数的另一种写法而已。

如果程序中的幻数都以符号常量的形式出现，对程序进行大量修改就会相对容易很多。

在兼有值与赋值两种功能的表达式中，赋值结合次序是由右至左。

char类型的字符是小整数，因此char类型的变量和常量在算术表达式中等价于int类型的变量和常量。

程序中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失，这也是其他语言通常把这类变量称为 *自动变量* 的原因。
如果 *自动变量* 没有赋值，则其中存放的是无效值。
 *外部变量* 必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。在每个需要访问外部变量的函数中，必须声明相应的外部变量，此时声明其类型。
声明时可以用 *extern*语句显示声明，也可以通过上下文隐式声明。
在源文件中，如果外部变量的定义出现在使用它的函数之前，那么在那个函数中就没有必要使用extern声明。
在通常的做法中，所有外部的变量的定义都是放在源文件中的开始处，这样就可以省略extern声明。
如果程序包含在多个源文件中，而某个变量在file1中定义，在file2和file3文件中使用，那么在文件file2与file3中就需要使用extern声明来建立该变量与其定义之间的联系。

"定义"表示创建变量或分配存储单元，而"声明"指的是说明变量的性质，但并不分配存储单元。

过分依赖外部变量会导致一定的风险，因为它会使程序中的数据关系模糊不清--外部变量的值可能会被意外地或不经意地修改，而程序的修改又变得十分困难。

* 第二章 类型、运算与表达式
  标准函数strlen(s)可以返回字符串参数s的长度，但长度不包括末尾的'\0'。

  枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于#define语句来说，它的优势在于常量值可以自动生成。

  所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。
  
  如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式。
  默认情况下，外部变量与静态变量将被初始化为0。未经显式初始化的自动变量的值为未定义的(即无效值)。
  
  对数组而言，const限定符指定数组所有元素的值都不能被修改。
  const限定符也可配合参数使用，它表明函数不能修改数组元素的值。
  如果试图修改const限定的值，其结果取决于具体的实现。
  
  逻辑非运算符!的作用是将非0操作数转换为0，将操作数0转换为1。
** 类型转换 
  一般来说，自动转换是指把"比较窄"操作数转换为"比较宽的"操作数，并且不丢失信息的转换。
  
  C语言没有指定char类型的变量是无符号变量还是有符号变量。
  C语言定义保证了机器的标准打印字符集中的字符不会是负值，因此，在表达式中这些字符总是正值。但在，存储在字符变量中的位模式在某些机器中可能是负的，
而在另一些机器中可能是正的。为了保证程序的可移植性，如果要在char类型的变量中存储非字符数据，最好指定signed或unsigned限定符。

 注意，表达式中的float类型的操作数不会自动转换为double类型，这一点与最初的定义有所不同。一般来说，数学函数使用double的变量。
使用float类型主要是为了在使用较大的数组时节省存储空间，有时也是为了节省机器执行时间(双精度算术运算特别费时)。

 带符号与无符号值之间的比较运算是与机器相关的，因为它们取决于不同整数类型的大小。譬如-1L<1U, -1L>1UL(-1L被转换成UL,转成了正数)
 
 当把较长的整数转换为较短的整数或char类型时，超出的高位部分将被丢弃。
 
 当被double类型转换为float类型时，是进行四舍五入还是截取取决于具体的实现。
 
 即使调用函数的参数是char或float类型，我们也把函数参数声明为int或double类型。
 
 通常情况下，参数是通过函数原型声明的。
 
 在对signed类型的带符号值进行右移时，某些机器将对左边空出的部分用符号位填补（即“算术移位”），而另一些机器则对左边空出来的部分用0填补（即“逻辑位移”）
 
 x = x & ~077
 注意，表达式x&~077与机器字长无关，它比形式为x&0177700的表达式要好，因为后者假定x是16位的数值。这种可移植的形式并没有增加额外开销，因为
 ~077是常量表达式，可以在编译时求值。
 
 赋值语句具有值，且可以用在表达式中，在这类表达式中，赋值表达式的类型是它的左操作数的类型，
 其值是赋值操作完成后的值。
 
 **同大多数语言一样，C语言没有指定同一运算符中多个操作数的计算顺序。** 如 x=f()+g(), f()是先于g()，还是后于g()调用，是未定义的。
 **类似地，C语言也没有指定函数各参数的求值顺序。** printf("%d %d\n", ++n, power(2,n)), 执行结果取决于编译器。
 **注意**
 a[i] = i++; 此问题，i是引用旧值，还是新值，C语言是未定义的，执行结果由编译器决定，国为最佳的求值顺序同机器结构有很大的关系。
 在任何一种编程语言中，如果代码的执行结果与求值顺序相关，则都不是好的程序设计风格。
* 第四章 函数与程序结构
  如果函数定义中省略了返回值类型，则默认为int类型。
  程序可以看成是变量定义和函数定义的集合。函数之间的通信可以通过参数、函数返回值、外部变量进行。
  return 表达式。
  在必要时，表达式将被转换为函数的返回值类型。表达式两边通常加一对圆括号，此处的括号是可选的。
  
  如果某个函数从一个地方返回时有返回值，而从另一个地方返回时没有返回值，该函数并不非法，但可能是一种出问题的征兆。
  在任何情况下，如果函数没有成功地返回一个值，则它的"值"肯定是无用的。
  
  如果没有函数原型，则函数将在第一次出现的表达式中被隐式声明。
  例如：
       sum += atof(line)
  atof被假设为返回值为int值，同时为了兼容旧版本，并不会对参数做假设。 并且，如果函数声明中不包含参数，编译程序不会对参数做任何假设，并会关闭所有的参数检查。

  规范的做法是：
  **如果函数带有参数，则要声明它们；如果没有参数，则使用void进行声明**

  由于C语言主允许在一个函数中定义其他函数，因此函数本身是“外部”的。默认情况下，外部变量与函数具有下列性质:
  通过同一个名字对外部变量的所有引用(即使这种引用来自于单独编译的不同函数)实际上都是引用的同一个对象(标准中把这一性质称为外部链接)
  
  名字的作用域指的是程序中可以使用该名字的部分。
  外部变量或函数的作用域从声明它的地方开始，到其所在的(待编译)文件的末尾结束。

  如果要在外部变量的定义之前使用该变量，或者外部变量的定义与声明不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字 **extern**。
  
  变量声明用于说明变量的属性(主要是变量的类型),而变量定义除此以外还将引起存储器的分配。

  在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其它文件可以通过extern声明来访问它。
  
  用 *static*  声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译文件的剩余部分。

  static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。

  *register* 变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。
  register变量只适用于自动变量以及函数的形式参数。
  无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的。

  在一个好的程序设计中，应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，很可能引起混乱和错误。

  在不进行显示初始化的情况下，外部变量与静态变量都将被初始化为0, 而自动变量及寄存器变量的初值则没有定义（即初值为无用的信息）
  对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次（从概念上讲是在程序开始执行前进行初始化）

  int days[13] = {1,2}
  如果初始化表达的个数比数组元素少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0。
  
  递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归的代码更易于编写与理解。
** C预处理器
*** 宏替换
  *#* 与 *##*
  如果在替换文本中，参数名以 *#* 作为前缀则结果将是被扩展 为由实际参数替换该参数的带引号的字符串。
  #define dprint(expr) printf(#expr " = %g\n", expr)
  使用语句
  dprint(x/y);
  调用该宏时，该宏将被扩展为:
  printf("x/y" " = %g\n", expr) 等价于printf("x/y = %g\n", x/y)
  
  如果替换文本中的参数与 *##* 相邻，则该参数将被实际参数替换，##与前后的空白符将被删除，并对替换后的结果重新扫描。

