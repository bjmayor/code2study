* 第一章 UNIX基础知识
操作系统有两个含义：
1. 仅指内核，它控制计算机硬件资源，提供程序运行环境。
2. 广义上，包括内核和一些其它软件，如系统实用程序、应用软件、shell以及公用函数库等。 
** 文件与目录
   UNIX文件系统的大多数实现并不在目录项中存放属性。有inode就够。

   程序的正确性是由硬件->内核->系统调用->标准库函数->第三方库->程序员 逐步保证的。
** 程序与进程
   程序是存放在磁盘上，处于某个目录中的一个可执行文件。使用6个exec函数中的一个由内核将程序读入存储器，并使其执行。
   
   有三个用于进程控制的主要函数：fork、exec和waitpid。
*** 线程和线程ID
    通常，一个进程只有一个控制线程，同一时刻只执行一组机器指令。
    在一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。
** 出错处理
   当UNIX函数出错时，一般返回一个负值，而且整型变量errno通常被设置为含有附加信息的一个值。
   返回一个指向对象指针的大多数函数，在出错时，将返回一个null指针。

   POSIX和ISO C将errno定义为这样一个符号，它扩展成为一个可修改的整型左值(lvalue)。这可以是包含出错编号的一个函数，或者是一个返回出错编号指针的函数。
   extern int * __errno_location(void);
   #define errno (*__errno_location())
   在支持多线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno以避免一个线程干扰另一个线程。
   对于errno应当知道两条规则：
   1. 如果没有出错，则其值不会被一个例程清除。因为，仅当函数的返回值指明出错时，才检验其值。
   2. 任一函数都不会将errno值设为0,在<errno.h>中定义的所有常量都不为0。
 
** 用户标识
   对于权限，使用数值用户ID和数值值ID是历史上形成的。1是数字比字符串的存储空间小,每个文件都会存放用户ID和组ID;2是查验权限期间，比较整数更快。
   
** 信号
   信号是通知进程已发生某种情况的一种技术。

   进程处理信息有三种选择：
   1. 忽略信号。
   2. 按系统默认方式处理。
   3. 提供一个信号捕捉函数，自定义处理。

   在键盘上产生信号的办法,中断键盘(Ctrl+C)和退出键(Ctrl+\)。
   
** 时间值
   长期以来，UNIX系统一直使用两种不同的时间值。
   1. 日历时间。自1970年1月1日00:00:00以来UTC所经过的秒数。
   2. 进程时间。也被称为CPU时间，用来度量进程使用的中央处理器资源。
      1. 时针时间
      2. 用户CPU时间
      3. 系统CPU时间。


* 第二章 UNIX标准化及实现
** UNIX标准化
   所有标准化工作的一个重要部分是对每种实现必须定义的各种限制进行说明。
  名词解释:
  ISO(International Organization for Standardization), 国际标准化组织。
  IEC(International Electrotechnical Commission),国际电子技术委员会。
  IEEE(Institude of Electrical and Electronics Engineers), 电气与电子工程师协会。
  POSIX(Portable Operating System Interface), 可移植的操作系统接口。
  Single UNIX Specification, 单一UNIX规范。
  ANSI C(American National Standards Institute),美国国家标准协会。

*** ISO C
    ISO C标准的意图是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不只是UNIX系统。
    此标准不仅定义了C程序设计语言的语法和语义，还定义了其标准库。
    
    ISO C标准定义的头文件(24个区)
    | 头文件       | FreeBSD5.2.1 | Linux2.4.22 | Mac OS X 10.3 | Solaris9 | 说明                     |
    | <assert.h>   | *            | *           | *             | *        | 验证程序断言             |
    | <complex.h>  | *            | *           | *             |          | 支持复数算术运算         |
    | <ctypes.h>   | *            | *           | *             | *        | 字符类型                 |
    | <errno.h>    | *            | *           | *             | *        | 出错码                   |
    | <fenv.h>     |              | *           | *             | *        | 浮点环境                 |
    | <float.h>    | *            | *           | *             | *        | 浮点常量                 |
    | <inttypes.h> | *            | *           | *             | *        | 整形格式转换             |
    | <iso646.h>   | *            | *           | *             | *        | 替代关系操作符宏         |
    | <limits.h>   | *            | *           | *             | *        | 实现常量                 |
    | <locale.h>   | *            | *           | *             | *        | 局部类别                 |
    | <math.h>     | *            | *           | *             | *        | 数学常量                 |
    | <setjmp.h>   | *            | *           | *             | *        | 非局部goto               |
    | <signal.h>   | *            | *           | *             | *        | 信号                     |
    | <stdarg.h>   | *            | *           | *             | *        | 可变参数表               |
    | <stdbool.h>  | *            | *           | *             | *        | 布尔类型和值             |
    | <stddef.h>   | *            | *           | *             | *        | 标准定义                 |
    | <stdint.h>   | *            | *           | *             |          | 整形                     |
    | <stdio.h>    | *            | *           | *             | *        | 标准IO库                 |
    | <stdlib.h>   | *            | *           | *             | *        | 实用程序函数             |
    | <string.h>   | *            | *           | *             | *        | 字符串操作               |
    | <tgmath.h>   |              | *           |               |          | 通用类型数学宏           |
    | <time.h>     | *            | *           | *             | *        | 时间和日期               |
    | <wchar.h>    | *            | *           | *             | *        | 扩展的多字节和宽字符支持 |
    | <wctype.h>   | *            | *           | *             | *        | 宽字符分类和映射支持     |
    
*** IEEE POSIX
    可移植的操作系统接口，原来指的是操作系统接口，后来扩展成包括很多标记为1003的标准及标准草案，包括shell和实用程序。
* 第三章 文件I/O
** 引言
   UNIX系统中的大多数文件I/O只需要用到5个函数:open、read、write、lseek以及close。
   
   本章说明的函数经常被称为不带缓冲的I/O。术语 **不带缓冲** 指的是每个read和write都调用内核的一个系统调用。

   多个进程共享文件 相关的函数：dup、fcntl、sync、fsync和ioctl

** 文件描述符
   文件描述符的变化范围是0~OPEN_MAX。
** open函数

   #include <fcntl.h>
   int open(const char *pathname, int oflag, ... /* mode_t mode */);

   O_DSYNC和O_SYNC标志有微妙的区别。仅当文件属性需要更新以反映文件数据变化(例如，更新文件大小以反映文件中包含了更多的数据)时，O_DSYNC标志
   才影响文件属性。而设置O_SYNC标志后，数据和属性总是同步更新。当文件用O_DSYNC标志打开，在重写其现有的部分内容时，文件时间属性不会同步更新。与此相反，如果文件是用O_SYNC标志打开，那么对该文件的每一次
   write操作都将在write返回前更新文件时间, 这与是否改写现有字节或增写文件无关。
   
   由open返回的文件描述符一定是最小的未用描述符数值。
   
   若_POSIX_NNO_TRUNC有效，则在整个路径名超过PATH_MAX, 或路径名中任一文件名超过NAME_MAX时，返回出错状态，并将errno设置为ENAMETOOLONG。
   
** create函数

   #include <fcntl.h>
   int create(const char *pathname, mode_t mode);
   此函数等效于open(pathname, O_WRONLY | O_CREATE | O_TRUNC, mode);

** close函数
   
   #include <fcntl.h>
   int close(int filedes);

   关闭一个文件时还会释放该进程加在该文件上的所有 **记录锁**
   当一个进程终止时，内核自动关闭它所有打开的文件。

** lseek函数
   
   #include <fntl.h>
   off_t lseek(int filedes, off_t offset, int whence);

   可以用以下方式确认当前文件偏移量
   off_t currpos;
   currpos = lseek(fd,0,SEEK_CUR);

   这种方法也可以用来确定所涉及的文件是否可以设置偏移量。如果文件描述符引用的是一个管道、FIFO或网络套接字，则lseek返回-1,并将errno设置为ESPIPE。
   
   通常，文件的当前偏移量是一个非负整数，但是，某些设备也可能允许负的偏移量。但对于普通文件，则其偏移量必须是非负值 。因为偏移量可能是负值，所以在比较lseek的返回值时
   应当谨慎，不要测试它是否小于0，而是要测试它是否等于-1。

   lseek仅将当前文件的偏移量记录在内核中，它并不引起任何I/O操作。然后该偏移量用于下一个读/写操作。

   文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一一次写操作将加和该文件，并在文件中构成一个空洞。位于文件中但没有写过的字节都被 **读为0**
   
   文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘快，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。

** read函数

   #include <fntl.h>
   ssize_t read(int filedes, void *buf, size_t nbytes);

   有多种情况可使实际读到的字节数少于要求读的字节数:
   1. 读普通文件时，在读到的要求字节数之前已达到了文件尾端。
   2. 从终端设备读时，通常一次最多读一行。
   3. 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。
   4. 当从管道或从FIFO读时，如若管道包含的字节少地所需要的字节数，那么read将只返回实际可用的字节数。
   5. 当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录。
   6. 当某一信号造成中断，而已经读了部分数据量时。
      
** write函数

   #include <fcntl.h>
   ssize_t write(int filedes, const void *buf, size_t nbytes);
   返回值通常和nbytes相同，不相同则出错。
   出错的原因可能是:
   1. 磁盘满
   2. 超过了一个给定进程的文件长度限制
      
** I/O效率
   BUFFSIZE的选取，和块大小sb_blksize一致，最高效。
   操作系统检测到顺序读时，会采取某种预读技术(read ahead)

** 文件共享
   内核使用三种数据结构表示打开的文件:
   1. 每个进程在进程表中都有一个记录项，记录项中包含有一张打开文件描述符表，每个描述符占一项。与每个描述符相关联的是：
      1. 文件描述符标志(close_on_exit)。
      2. 指向一个文件表项的指针。
   2. 内核为所有打开文件维持一张文件表。每个文件表项包含：
      1. 文件状态标志
      2. 当前文件偏移量
      3. 指向该文件v节点表项的指针
   3. 每个打开文件都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作的函数的指针。对于大多数文件，v节点还包含了该文件的i节点。
      这些信息是在打开文件时从磁盘上读入内存的，所以所有关于文件的信息都是快速可供使用的。

   如果两个独立进程各自打开了同一个文件。打开该文件的每个进程都得到一个文件表项，但对一个给定的文件只有一个v节点表项。每个进程都有自己的文件表项的一个理由是：这种安排使每个进程都有它自己的对该文件的当前偏移量。
   
   可能有多个文件描述符项指向同一个文件表项。譬如dup,fork。
   
   文件描述符标志和文件状态标志在作用域方面的区别，前者只用于一个进程的一个文件描述符，而后者则适用于指向该文件表项的任何进程中的所有描述符。
   
   当多个进程写同一个文件时，可能产生预期不到的效果。解决办法，参考下面的原子操作的概念。

** 原子操作
*** 添写至一个文件
    任何一个需要多个函数调用的操作都不可能是原子操作，因为在两个函数调用之间，内核可能会临时挂起该进程。
    UNIX提供了O_APPEND标志，内核在写之前会将偏移量设置为文件尾端处，而不用调用lseek。
*** pread和pwrite函数
    把lseek和I/O读写捆绑成了原子操作。由内核提供。

    #include <unistd.h>
    ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);
    ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);
*** 创建一个文件
    open提供O_CREATE和O_EXCL选项。当同时指定这两个选项，而该文件又已经存在时，open将失败。
    一般而言，原子操作指的是由多步组成的操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤中的一个子集。
** dup和dup2函数
   这两个函数都可用来复制一个现存的文件描述符，返回的新文件描述符与参数fieldes共享同一个文件表项。
   
   #include <unistd.h>
   int dup(int fieldes);
   int dup2(int fieldes, int fieldes2);

   复制一个描述符的另一种方法是fcntl函数。
   调用
   dup(filedes);
   等效于
   fcntl(filedes, F_DUPFD, 0)

   而调用
   dup2(filedes, filedes2);
   等效于
   close(filedes);
   fcntl(filedes, F_DUPFD, filedes2);
   第二个有区别，主要在于一个是原子操作，另一个不是。
** sync、fsync和fdatasync函数
   传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。写->缓冲区->输出队列->队首时，实际的I/O操作。这种方式称为延迟写。
   
   延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度。当系统发和故障时，这种延迟可能造成文件更新内容的丢失。
   为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数。

   #include <unistd.h>
   int fsync(int filedes);
   int fdatasync(int filedes);

   void sync(void);
   
   sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。
   通过称为update的系统守护进程会周期性地(一般每隔30秒)调用sync函数。这就保证了定期冲写内核的块缓冲区。

   fsync会等待磁盘操作结束，适合数据库应用。
** fcntl函数
   - Note taken on [2016-04-05 Tue 06:56]
   
   #include <fcntl.h>
   int fcntl(int filedes, int cmd, ... /* int arg */);

   fcntl函数有5种功能：
   1. 复制一个现有的描述符(cmd = F_DUPFD)
   2. 获得/设置文件描述符标记(cmd = F_GETFD或F_SETFD)
   3. 获得/设置文件状态标志(cmd = F_GETFL或F_SETFL)
   4. 获得/设置异步I/O所有权(cmd = F_GETOWN或F_SETOWN)
   5. 获得/设置记录锁(cmd = F_GETLK、F_SETLK或F_SETLK)
      
   由磁盘驱动器将队列数据写到磁盘上。
** ioctl函数
   ioctl函数是I/O操作的杂物箱。终端I/O是ioctl的最大使用方面。

   #include <unistd.h> /* System V */
   #include <sys/ioctl.h> /* BSD and linux */
   #include <stropts.h> /* XSI STREAMS */

   int ioctl(int filedes, int request, ... );
   
   每个设备驱动程序都可以定义它自己专用的一组ioctl命令。系统则为不同种类的设备提供通用的ioctl命令。
** /dev/fd
   打开文件/dev/fd/n 等效于复制描述符n。
   
   /dev/fd文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理其它路径名的相同方式处理标准输入和输出。
   
   filter file2 | cat file1 - file3 | lpr
   在命令行中用"-" 作为一个参数，特指标准输入或标准输出，这已由很多程序采用。但是这会带来一些问题，例如若用"-"指定第一个文件名，那么它看起来就像指定了命令行中的一个选项，/dev/fd则提高了文件名参数的一致性，也更加清晰。
* 第四章 文件和目录
** stat、fstat和lstat函数
   #include <sys/stat.h>
   int stat(const char *restrict pathname ,struct stat *restrict buf);
   int fstat(int filedes, struct stat *buf);
   int lstat(const char *restrict pathname, struct stat *restrict buf);
   
   restrict是C99引入，用来告诉编译器，指针是唯一操作对象的方式。
   如果pathname是符号链接，lstat返回的符号链接本身的有关信息，stat返回的是符号链接引用文件的信息。
   
   struct stat {
   mode_t st_mode;/* file type & mode */
   ino_t st_ino; /* i-node number */
   dev_t st_dev; /* device number (file system) */
   dev_t st_rdev; /* device number for special files*/
   nlink_t st_nlink; /* number of links */
   uid_t st_uid; /* user ID of owner */
   gid_t st_gid; /* group ID of owner */
   off_t st_size; /* size in bytes, for regular files */
   time_t st_atime;/* time of last access*/
   time_t st_mtime;/* time of last modification */
   time_t st_ctime; /* time of last file status change */
   blksize_t st_blksize; /* best I/O block size */
   blkcnt_t st_blocks; /* number of disk blocks allocated */
   }
** 文件类型
   文件类型有：
   1. 普通文件
   2. 目录文件
   3. 块特殊文件。这种文件类型提供对设备带缓冲的访问，每次访问以固定长度为单位进行。
   4. 字符特殊文件。不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。
   5. FIFO。用于进程间通信，也叫命名管道。
   6. 套接字，用于进程间网络通信，也可用于本机上进程间非网络通信。
   7. 符号链接
   
** 设置用户ID和设置组ID
   与每个进程相关的用户ID和组ID
   | 项目             | 说明                             |
   |------------------+----------------------------------|
   | 实际用户ID       | 我们实际上是谁                   |
   | 实际组ID         |                                  |
   | ----------       | -------------------------        |
   | 有效用户ID       | 用于文件访问权限检查             |
   | 有效组ID         |                                  |
   | 附加组ID         |                                  |
   | ----------       | -------------------------------- |
   | 保存的设置用户ID | 由exec函数保存                   |
   | 保存的设置组ID   |                                  |
   
   一般来说，有效用户ID就是实际用户ID,有效组ID就是实际组ID。但在文件模式字(st_mode)中有两个特殊标志。
   1. 设置用户ID, 当设置时，有效用户ID设置为文件所有者用户ID
   2. 设置组ID,当设置时，有效组ID设置为文件所有者组ID
   
** 文件访问权限
   目录的执行权限位被称为搜索位。
   
   对于目录的读权限和执行权限意义是不同的。读权限允许我们读目录，获得在该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，
   对该目录的执行权限使我们可以通过该目录(也就是搜索该目录，寻找一个特定的文件名)
   
   内核进行的文件访问权限测试：
   1. 若进程的有效用户ID是0，则允许访问。
   2. 若进程的有效用户ID等于文件所有者ID.那么，若所有者有权限，则允许。
   3. 若进程的有效组ID或进程有附加组ID之一等于文件的组ID,则依赖于组ID的权限位。
   4. 若其它用户适当的访问权限位被设置，则允许访问。

   说明：2,3,4按顺序检查时，如进程拥有此文件，则只检查第2步，3,4步不检查。其它情况类似。
** 新文件和目录的所有权
   新文件的用户ID设置为进程的有效用户ID。
   关于组ID,有如下设定：
   1. 新文件的组ID可以是进程的有效组ID。
   2. 新文件的组ID可以是它所在目录的组ID。
   不同系统选择不一样，mac是第2个。
** access函数
   access函数是按实际用户ID和实际组ID进行访问权限测试的。

   #include <unistd.h>
   int access(const char *pathname, int mode);

   其中，mode是按下表按位或。
   | mode | 说明       |
   |------+------------|
   | R_OK | 测试读权限 |
   | W_OK | 测试写权限 |
   | X_OK | 测试执行权限 |
   | F_OK | 测试文件是否存在 |
** umask函数
   umask函数为进程设置文件模式创建屏蔽字，并返回以前的值。（少数几个没有出错返回函数中的一个)
   
   #include <sys/stat.h>
   mode_t umask(mode_t cmask);
   
   对于任何在文件模式创建屏蔽字中为1的位，在文件mode中的相应位则一定被关闭。
  
   在登录时，会由shell启动文件设置一次umask,然后就不变了。
   在编写创建新文件的程序时，如果要确保指定的访问权限位已激活，那么必须在进程运行时修改umask值。
   更改进程的文件模式创建屏蔽字并不影响父进程。
** chmod和fchmod函数
   
   #include <sys/stat.h>
   int chmod(const char *pathname, mode_t mode);
   int fchmod(int filedes, mode_t mode);

   为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID, 或者该进程必须有超级用户权限。
   
   chmod函数更新的只是i节点最近一次被更改的时间。
   
   设置用户ID和设置组ID由于安全原因。chmod有特殊处理, 在下列两个情况下会自动清除两个权限位。
   1. 在Solaris等系统上，如果设置普通文件的粘住位(S_ISVTX),而且又没有超级权限，那么mode中的粘住位将自动被关闭。
   2. 新创建文件的组ID可能不是调用进程所属的组(可能是父目录的组ID)。特别地，如果新文件的组ID不等于进程的有效组ID或者进程附加组ID中的一个，以及用户没有超级用户权限，那么设置组ID位将会自动被关闭。
** 粘住位
   历史技术，在UNIX还没有分页技术之前使用的。当时是用于可执行文件。
   在一般UNIX文件系统中，文件的各数据块很可能是随机存放的。为了加速程序的载入，会在第一次执行后，把程序的正文部分存放到交换区，文件在交换区是连续的，这就是称为粘住位的原因，
   也叫保存正文位(S_ISVTX)。
   现在由于配置有虚拟存储系统以及快速文件系统，所以不再需要这种技术。
   
   现今的系统扩展了粘住位的使用范围, 针对目录。如果对一个目录设置了粘住位，则只有对该目录有写权限的用户在满足下列条件之一的情况下，才能删除或更名该目录下的文件：
   1. 拥有该文件
   2. 拥有该目录
   3. 是超级用户
** chown、fchown和lchown函数
   
   #include <unistd.h>
   int chown(const char *pathname, uid_t owner, gid_t group);
   int fchown(int filedes, uid_t owner, gid_t group);
   int lchown(const char *pathname, uid_t owner, gid_t group);

   在符号链接的情况下，lchown更改符号链接本身的所有者，而不是该符号链接所指向的文件。
   
   如若两个参数owner或group中的任意一个是-1, 则对应的ID不变。
   基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者。这样做的原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。系统V则允许任一用户更改他们所拥有的文件的所有者。
   
   若_POSIX_CHOWN_RESTRICTED对指定的文件起作用，则
   1. 只有超级用户进程能更改该文件的用户ID。
   2. 若满足下列条件，一个非超级用户进程就可以更改该文件的组ID:
      1. 进程拥有此文件(其有效用户ID等于该文件的用户ID)。
      2. 参数owner等于-1或文件的用户ID,并且参数group等于进程的有效组ID或进程的附加组ID之一。

   如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组ID位都会被清除。
** 文件长度
   对于目录，文件长度通常是一个数(例如16或512)的倍数。
   对于符号链接，文件长度是文件名中的实际字节数。

*** 文件中的空洞
    ls 看的是文件长度，du看的是文件所使用的磁盘空间总量。
    正常的I/O操作读取整个文件长度，会把空洞读成0,如果使用实用程序(如cat)复制这种文件，那么所有空洞会被填满，填写为0。从而实际占用磁盘空间。
    
    大文件,du报告的长度比ls的长，因为文件系统使用了若干块以存放指向实际数据块的各个指针。
    
** 文件截短
   #include <unistd.h>
   int truncate(const char *pathname, off_t length);
   int ftruncate(int filedes, off_t length);

   这两个函数将把现有的文件长度截短为length字节。如果文件以前的长度>length,则length以后的数据不能再访问，如果以前的长度短于length,则其效果与系统有关。遵循XSI的系统会增加文件长度，产生空洞。

** 文件系统
   文件系统分类的多种实现：
   1. UFS, UNIX file system, 传统的基于BSD的UNIX文件系统。
   2. PCFS, 读、写DOS格式化软盘的文件系统。
   3. HSFS, 读CD的文件系统。
      
   下面说的是UFS。
   1个磁盘分成一个或多个分区,每个分区可以包含一个文件系统。
   文件系统由自举块、超级块和若干个柱面组 组成。
   每个柱面由 超级块副本、配置信息、i节点图、块位图、i节点和数据块组成。

   i节点是固定长度的记录项，它包含有关文件的大部分信息:
   文件类型、文件访问权限位、文件长度和指向该文件所占用的数据块的指针等等。
   
   只有两项数据存放在目录项中：文件名和i节点编号。
   
   每个文件系统各自对它们的i结点进行编号，因此目录项中的i节点编号数指向同一文件系统中的相应i节点，不能使一个目录项指向另一个文件系统的i节点。
   
** link、unlink、remove和rename函数

   #include <unistd.h>
   int link(const char *existingpath, const char *newpath);

   创建新目录项newpath, 它引用现有的文件existingpath。
   创建新目录项以及增加链接计数应当是个原子操作。
   很多文件系统不允许对于目录的硬链接(可能形成循环)
   
   删除目录项，可以调用unlink函数。
   
   #include <unistd.h>
   int unlink(const char *pathname);

   只有当链接计数达到0时，该文件的内容才可以被删除。另一个条件也会阻止删除文件的内容--只要有进程打开了该文件，其内容也不能删除。
   关闭一个文件时，内核首先检查打开该文件的进程数。如果该数达到0，然后内核检查其链接数，如果这个数也是0，那么就删除该文件的内容。
  
   上面的特性经常用来确保即使是在该程序崩溃时，它所创建的临时文件也会不会遗留下来。进程用open或creat创建一个文件，然后立即调用unlink。
   

  remove函数解除对一个文件或目录的链接。对于文件，remove = unlink, 对于目录， remove = rmdir 
  #include <stdio.h>
  int remove(const char *pathname);
  
  文件或目录用rename函数更名。
  #include <stdio.h>
  int rename(const char *oldname, const char *newname);
  
  1. 如果oldname指的是一个文件而不是目录，那么为该文件/符号链接更名。
  2. 如若oldname指的是一个目录，则为该目录更名。
  3. 如若oldname或newname引用符号链接，则处理的是符号链接本身，而不是它所引用的文件。
  4. 作为一个特例，如果oldname=newname,函数直接返回。
  如若newname已存在，则要求进程对其有写权限。另外，调用进程需要对包含oldname以及包含newname的目录具有写和执行权限。
  
** 符号链接
   符号链接是指向一个文件的间接指针，它与硬链接不同，硬链接直接指向文件的i结点。引入符号链接的原因是为了避免硬链接的一些限制：
   1. 硬链接通常要求链接和文件位于同一文件系统
   2. 只有超级用户才能创建指向目录的硬链接
      
      各个函数对符号链接的处理
      | 函数     | 不跟随符号链接 | 跟随符号链接 |
      |----------+----------------+--------------|
      | access   |                | *            |
      | chdir    |                | *            |
      | chmod    |                | *            |
      | chown    | *              | *            |
      | creat    |                | *            |
      | lchown   | *              |              |
      | link     |                | *            |
      | lstat    | *              |              |
      | open     |                | *            |
      | opendir  |                | *            |
      | pathconf |                | *            |
      | readlink | *              |              |
      | remove   | *              |              |
      | rename   | *              |              |
      | stat     |                | *            |
      | truncate |                | *            |
      | unlink   | *              |              |
      |----------+----------------+--------------|
      
      有个特例，同时用O_CREATE和O_EXCL两者调用open函数。在些情况下，若路径名引用符号链接，open将出错返回，并将errno设置为EEXIST。这种处理方式的意图是堵塞一个安全性漏洞，
      使具有特权的进程不会被诱骗对不适当的文件进行写操作。
   
** symlink和readlink函数
   symlink创建符号链接
   
   #include <unistd.h>
   int symlink(const char *actualpath, const chat *sympath);
   
   因为open函数会跟随符号链接，所以需要一种方法打开链接本身，并读该链接中的名字。readlink提供

   #include <unistd.h>
   ssize_t readlink(const char * restrict pathname, char *restrict buf, size_t bufsize);
   此函数组成了open、read、close。成功返回读入buf的字节数。。 **需要注意的是buf不以null字符终止**。

** 文件的时间
   与每个文件相关的三个时间值
   | 字段     | 说明                    | 例子         | ls选项 |
   |----------+-------------------------+--------------+--------|
   | st_atime | 文件数据的最后访问时间  | read         | -u     |
   | st_mtime | 文件数据的最后修改时间  | write        | 默认   |
   | st_ctime | i节点状态的最后修改时间 | chmod、chown | -c     |
   |----------+-------------------------+--------------+--------|

   注意，系统并不保存对一个i节点的最后一次访问时间，所以access和stat函数并不更改这三个时间中的任一个。
** utime函数
   一个文件的访问和修改时间可用utime函数更改。
   
   #include <utime.h>
   int utime(const char *pathname, const struct utimbuf *times);

   数据结构如下:
   struct utimbuf {
       time_t actime;/* access time */
       time_t modtime;/* modification time */
   }
   
   此函数的操作以及执行它所要求的特权取决于times参数是否是NULL。
   1. 如果times是一个空指针，则访问时间和修改时间两者都设置为当前时间。为了执行此操作必须满足下列两条件之一：进程的有效用户ID必须等于该文件的所有者ID；或者进程对该文件有写权限。
   2. 如果times是非空指针，则访问时间和修改时间被设置为times所指向结构中的值。此时，进程的有效用户ID必须等于该文件的所有者ID,或者进程必须是一个超级用户进程。
** mkdir和rmdir函数

   #include  <sys/stat.h>
   int mkdir(const char *pathname, mode_t mode);
   
   此函数创建一个新的空目录。其中，.和..目录项是自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。
   
   对于目录通常至少要设置1个执行权限位，以允许访问该目录中的文件名.
   
   用rmdir函数可以删除一个空目录。空目录是指只包含.和..这两项的目录。
   
   #include <unistd.h>
   int rmdir(const char *pathname);
   
  如果调用此函数使目录的链接计数成为0,并且也没有其他进程打开此目录，则释放由此目录占用的空间。
  如果在链接计数达到0时，有一个或几个进程打开了此目录，则在此函数返回前删除最后一个链接及.和..项。
  另外，在此目录中不能再创建新文件。但是在最后一个进程关闭它之前并不释放此目录。
** 读目录
   为了防止文件系统产生混乱，只有内核才能写目录。一个目录的写和执行权限位，决定了在该目录下能否创建新文件和删除文件，它们并不表示能否写目录本身。
   
   目录的实际格式依赖UNIX系统，特别是其文件系统的具体设计和实现。
   很多实现阻止应用程序使用read函数读取目录的内容，从而进一步将应用程序与目录格式中与实现相关的细节隔离开。
   
   #include <dirent.h>
   DIR *opendir(const char *pathname);
   struct dirent *readdir(DIR *dp);

   void rewinddir(DIR *dp);
   int closedir(DIR *dp);
   
   long telldir(DIR *dp);
   
   void seekdir(DIR *dp, long loc);
   
   最基础的定义:
   struct dirent {
       ino_t d_ino;
       char d_name[NAME_MAX + 1];
   }
 
** chdir、fchdir和getcwd函数
   每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当前工作目录是进程的一个发生，起始目录则是登录名的一个属性。

   进程通过chdir或fchdir函数可以更改当前工作目录。
   #include <unistd.h>
   int chdir(const char *pathname);
   int lchdir(int filedes);
   
   内核为每个进程只保存指向该目录v节点的指针等目录本身的信息，并不保存该目录的完整路径名。
   通过getcwd可以取得完整路径名。
   #include <unistd.h>
   char *getcwd(char *buf, size_t size);
   
** 设备特殊文件
   st_dev 与  st_rdev容易引起混淆。
   1. 每个文件系统所在的存储设备都由其主、次设备号表示。主设备号标识设备驱动程序，有时编码为与其通信的外设板；次设备号标识特定的子设备。次设备号标识分区?
   2. 可以用宏major和minor来访问主、次设备号。
   3. 系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点。
   4. 只有字符特殊文件和块特殊文件才有st_rdev值，此值包含实际设备的设备号。
      
* 标准I/O库
** 引言
   标准I/O库处理很多细节，例如缓冲区分配，以优化长度执行I/O等。
** 流和FILE对象
   不带缓冲的I/O是针对文件描述符的。标准I/O库，是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。
   
   流的定向决定了所读、写的字符是单字节还是多字节的。
   当一个流最初创建时，它并没有定向。
   如若在未定向的流上使用一个多字节I/O函数(见<wchar.h>)，则该流的定向设置为宽定向。
   如若在未定向的流上使用一个单字节I/O函数，则该流的定向设置为字节定向。
   
   只有两个函数可以改变流的定向。freopen清楚流的定向, fwide函数设置流的定向(前提是流未定向)
   
   #include <stdio.h>
   #include <wchar.h>
   int fwide(FIFL *fp, int mode);

   fwide无出错返回，解决办法是：在调用fwide前先清除errno, 从fwide返回时检查errno的值。
** 标准输入、准备输出和标准出错
   标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。

   标准I/O提供了三种类型的缓冲：
   1. 全缓冲。 在填满标准I/O缓冲区后才进行实际I/O操作。一般用于磁盘文件。
      flush有两个意思。
      1. 在标准I/O库方面，flush(冲洗)意味着将缓冲区中的内容写到磁盘上。
      2. 在终端驱动程序方面，flush（刷清)表示丢弃已存储在缓冲区中的数据。
   2. 行缓冲。 当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。一般用于终端。
      行缓冲的两个限制：
      1. 缓冲区满时，也会进行I/O操作。
      2. 任何时候只要通过标准I/O库要求从(a)一个不带缓冲的流，或者(b)一个行缓冲的(它要求从内核中得到数据)流得到输入数据，那么就会造成冲洗所有行缓冲输出流。
   3. 不带缓冲。 标准I/O库不对字符进行缓冲存储。一般用于标准错误stderr。
      
   ISO C要求下列缓冲特征：
   1. 当且仅当标准输入和标准输出并不涉及交互式设备时，它们才是全缓冲的。
   2. 标准出错决不会是全缓冲的。
   
   很多系统默认使用下列类型的缓冲：
   1. 标准出错是不带缓冲的。
   2. 如若是涉及终端设备的其他流，则它们是行缓冲的；否则是全缓冲的。
      
   以下函数用来更改缓冲类型：
   #include <stdio.h>
   void setbuf(FILE *restrict fp, char *restrict buf);
   int setvbuf(FILE *restrict fp , char *restrict buf, int mode, size_t size);

   setbuf用来打开/关闭缓冲机制。 为了带缓冲进行I/O, 参数buf必须指向一个长度为BUFSIZE的缓冲区。通常在此之后就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓冲。
   关闭缓冲，把buf设置为NULL。

   使用setvbuf， 我们可以精确指定所需要的缓冲类型。mode参数：
   1. _IOFBF  全缓冲
   2. _IOLBF 行缓冲
   3. _IONBF 不带缓冲

   注意：如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流。
         另外， 有些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可以存放在缓冲区的实际数据字节数少于size。
         一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。在这种情况下关闭此流时，标准I/O库将自动释放缓冲区。
         
         
   #include <stdio.h>
   inf fflush(FILE *fp);

   用于强制冲洗一个流。若fp为NULL, 则此函数将导致所有输出流被冲洗。
** 打开流
   
   #include <stdio.h>
   FILE *fopen(const char *restrict pathname, const char *restrict type);
   FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
   FILE *fdopen(int filedes, const char *type);

   1. fopen打开一个指定的文件
   2. freopen,在指定的流上打开文件。如果已经打开，则先关闭。若流已定向，则清除该定向。主要用于预定义的流：标准输入、标准输出和标准出错。
   3. fdopen获取一个现有的文件描述符，并使一个标准的I/O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符。
      

   当以读和写类型打开一文件时(type中+符号),具有下列限制：(同一块缓冲只有输入/输出数据，不能同时存在)
   1. 如果中间没有fflush、fseek、fsetpos或rewind, 则在输出的后面不能直接跟随输入。
   2. 如果中间没有fseek、fsetpos或rewind, 或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出。

      
   调用fclose来关闭一个打开的流
   
   #include <stdio.h>
   int fclose(FILE *fp);

   在该文件被关闭之前，冲洗缓冲区中的输出数据。丢弃缓冲区中的任何输入数据。

   当一个进程正常终止时，则所有带未写缓冲数据的标准I/O流都会被冲洗，所有打开的标准I/O流都会被关闭。
** 读和写流
   一旦打开了一个流，则可在三种不同类型的非格式化I/O中进行选择：
   1. 每次一个字符的I/O。
   2. 每次一行的I/O。
   3. 直接I/O,也叫二进制I/O，每次读写一个对象。(fread和fwrite支持)。

*** 输入函数
    每次一个字符的I/O
    #include <stdio.h>
    int getc(FILE *fp);
    int fgetc(FILE *fp);
    int getchar(void);

    getc可以实现为宏，则fgetc只能是函数。

    注意：不管是出错还是到达文件尾端，这三个函数都返回同样的值。为了区分这两种不同的情况，必须调用ferror或feof。
    #include <stdio.h>
    int ferror(FILE *fp);
    int feof(FILE *fp);
    void clearerr(FILE *fp);

    在大多数实现中，为每个流在FILE对象中维持了两个标志：
    1. 出错标志。
    2. 文件结束标志。
    调用clearerr则清除这两个标志。

    从流中读取数据以后，可以调用ungetc将字符再压送回流中。
    #include <stdio.h>
    int ungetc(int c, FILE *fp);

    虽然ISO C允许实现支持任何次数的回送，但是它要求实现提供一次只送回一个字符。我们不能期望一次能送回多个字符。??? **为什么这样设定**
 
   回送的字符不必一定是上一次读到的字符。不能回送EOF。但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再次读则返回EOF。之所以这样做的原因是一次成功的ungetc调用
   会清除该流的文件结束标志。 
    
*** 输出函数
    对应于上面的三个输入函数。有三个输出函数
    #include <stdio.h>
    int putc(int c, FILE *fp);
    int fputc(int c, FILE *fp);
    int putchar(int c);
   
** 每次一行I/O
*** 输入函数
    #include <stdio.h>
    char *fgets(char *restrict buf, int n, FILE *restrict fp);
    char *gets(char *buf);
    
    缓冲区总是以null字符结尾。
    
    gets并不推荐使用，因为不能指定缓冲区的长度，可能造成缓冲区溢出(如若该行长于缓冲区长度），写到缓冲区之后的存储空间中，从而产生不可预料的后果。
    
    **处处是坑，难道需要更高级的语言，来避免这些坑。但专家级的程序员一定需要知道这些坑，并能直面这些坑**
*** 输出函数
    #include <stdio.h>
    int fputs(const char *restrict str, FILE *restrict fp);
    int puts(const char *str);
    
    如果总是使用fgets和fputs, 那么就会熟知在每行终止处我们必须自己处理换行符。
    
** 二进制I/O
   下列两个函数执行二进制I/O操作
   #include <stdio.h>
   size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
   size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
   
   两种常用的用法：
   1. 读或写一个二进制数组。
   2. 读或写一个结构。
      
   
   使用二进制I/O的基本问题是， 它只能用于读在同一系统上已写的数据。
   但是我们常遇到在一个系统上写的数据，要在另一个系统上进行处理。这种情况下，这两个函数可能不能正常工作。
   1. 在一个结构中，同一成员的偏移量可能因编译器和系统而异。即使在同一个系统上，一个结构的二进制存放方式也可能因编译器选项的不同而不同。
   2. 用来存储多字节整数和浮点值的二进制格式在不同的机器体系结构间也可能不同。

     
   在不同系统之间交换二进制数据的实际解决方法是使用较高级的协议。
** 定位流
   有三种方法定位标准I/O流。
   1. ftell和fseek函数。
   2. ftello和fseeko函数。
   3. fgetpos和fsetpos函数。

     
   需要移植到非UNIX系统上运行的应用程序应当使用fgetpos和fsetpos。

   #include <stdio.h>
   long ftell(FILE *fp);
   int fseek(FILE *fp, long offset, int whence);
   void rewind(FILE *fp);
   

   对于一个二进制文件，其文件位置指示器是从文件起始位置开始度量，并以字节为度量单位。
   对于文本文件，它们的文件当前位置可能不以简单的字节偏移量来度量。为了定位一个文本文件，whence一定要是SEEK_SET, 而且offset只能有两种值：0，或是对该文件调用ftell所返回的值。

   
   ftello和ftell只是返回值类型不一样。
   #include <stdio.h>
   off_t ftello(FILE *fp);
   int fseeko(FILE *fp, off_t offset, int whence);
   
   #include <stdio.h>
   int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
   int fsetpos(FILE *fp, const fpos_t *pos);
** 格式化I/O
*** 格式化输出
    4个函数
    
    #include <stdio.h>
    int printf(const char *restrict format, ...);
    int fprintf(FILE *restrict fp, const char *restrict format, ...);
    
    int sprintf(char *restrict buf, const char *restrict format, ...);
    int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
    
    sprintf在该数组的尾端自动加一个null字节，但该字节不包括在返回值中。
    
    注意，sprintf函数可能会造成由buf指向的缓冲区的溢出。调用者有责任确保该缓冲区足够大。为了解决这个问题，引入的snprintf函数。
    
    下列4种printf族的变体类似于上面的4种，但是可变参数表(...)代换成了arg。
    
    #include <stdarg.h>
    #include <stdio.h>
    
    int vprintf(const char *restrict format, va_list arg);
    int vfprintf(FILE *restrict fp, const char *restrict format, va_list arg);
    
    int vsprintf(char *restrict buf, const char *restrict format, va_list arg);
    int vsnprintf(char *restrict buf, size_t n, const char *restrict format, va_list arg);
    
*** 格式化输入
    3个scanf函数
    
    #include <stdio.h>
    int scanf(const char *restrict format, ...);
    int fscanf(FILE *restrict fp, const char *restrict format, ...);
    int sscanf(const char *restrict buf, const char *restrict format, ...);
    
    同printf族一样，scanf族也支持函数使用由<stdarg.h>说明的可变参数表。

    #include <stdarg.h>
    #include <stdio.h>
    int vscanf(const char *restrict format, va_list arg);
    int vfscanf(FILE *restrict fp, const char *restrict format, va_list arg);
    int vsscanf(const char *restrict buf, const char *restrict format, va_list arg);
** 实现细节
   可以通过流得到文件描述符

   #include <stdio.h>
   int fileno(FILE *fp);
** 临时文件
   ISO C标准I/O库提供了两个函数以帮助创建临时文件。
   
   #include <stdio.h>
   char *tmpnam(char *ptr);
   FILE *tmpfile(void);
   
   若ptr是NULL, 则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。
   下一次调用tmpnam时，会重写该静态区。

   若ptr不是NULL，则认为它指向长度至少是L_tmpnam个字符的数组。
   
   tempfile创建一个临时二进制文件(wb+),在关闭该文件或程序结束时将自动删除这种文件。
   
   XSI的扩展部分提供了另两个函数。
   
   #include <stdio.h>
   char *tempname(const char *directory, const char *prefix);
   
   允许调用者为所产生的路径名指定目录和前缀。对于目录有4种不同的选择，按下列顺序判断其条件是否为真，并且使用第一个为真的作为目标：
   1. 如果定义了环境变量TMPDIR, 则用其作为目录。
   2. 如果参数directory非NULL, 则用其作为目录。
   3. 将<stdio.h>中的字符串P_tmpdir用作目录。
   4. 将本地目录(通常是/tmp)用作目录。

   如果prefix非NULL, 则它应该是最多包含5个字符的字符串。
   
   XSI定义的第二个函数是mkstemp。类似于tmpfile, 返回的是临时文件的打开文件描述符。
   #include <stdlib.h>
   int mkstemp(char *template);
   
   与tmpfile不同的是，mkstemp创建的临时文件不会自动被删除。

   使用tmpnam和tempnam的一个不足之处是：在返回唯一路径名和应用程序用该路径名创建文件之间有一个时间窗口。
   在该时间窗口期间，另一个进程可能创建一个同名文件。
   tmpfile和mkstemp函数则不会产生此种问题，可以使用它们代替tmpnam和tempnam。
   
** 标准I/O的替代软件
   标准I/O库的一个不足之处是效率不高。有两次复制：从内核复制到标准I/O缓冲，从缓冲复制到用户程序的行缓冲。
   快速I/O库(fio)避免了这一点，其方法是使读一行的函数返回指向该行的指针，而不是将该行复制到另一个缓冲区中。
   sfio, 扩展了I/O流，不仅可以代表文件，也可以代表存储区；可以编写处理模块，并以栈方式将其压入I/O流；较好的异常操作。
   ASI, 使用了映射文件--mmap函数。ASI使用指针力图减少数据复制量。
   
   不可移植，但性能更好的 uClibc C库和newlibc C库，适用于嵌入式系统。
* 系统数据文件和信息
** 口令文件
   <pwd.h> paswd结构
   /etc/passwd文件中的字段
   | 说明         | struct passwd成员 |
   |--------------+-------------------|
   | 用户名       | char *pw_name     |
   | 加密口令     | char *pw_passwd   |
   | 数值用户ID   | uid_t pw_uid      |
   | 数值组ID     | uid_t pw_gid      |
   | 注释字段     | char *pw_gecos    |
   | 初始工和目录 | char *pw_dir      |
   | 初始Shell    | char *pw_shell    |
   | 用户访问类   | char *pw_class    |
   | 下次更改口令文件 | time_t pw_change  |
   | 账户到期时间     | time_t pw_expire  |
   
   为了阻止一个特定用户登录系统，有几种办法：
   1. 初始Shell 设置为 /dev/null
   2. 初始shell 设置为 /bin/false
   3. 初始shell 设置为 /bin/true
   4. 初始shell 设置为 nologin,需要系统支持。
   
   有些系统提供vipw命令来修改/etc/passwd文件。
   提供finger命令的某些系统支持注释字段中的附加信息。
   
   #include <pwd.h>
   struct passwd *getpwuid(uid_t uid);
   struct passwd *getpwna(const char *name);
   
   下列三个函数可用于读取整个口令文件。
   #include <pwd.h>
   struct passwd *getpwent(void);//打开文件
   void setpwent(void);//回到文件开头
   void endpwent(void);//关闭文件
   

** 阴影文件
   /etc/shadow文件中的字段
   | 说明                       | struct spwd成员 |
   |----------------------------+-----------------|
   | 用户登录名                 | char *sp_namp   |
   | 加密口令                   | char *sp_pwdp   |
   | 上次更改口令以来经过的时间 | int sp_lstchg   |
   | 经过多少天后允许更改       | int sp_min      |
   | 要求更改尚余天数           | int sp_max      |
   | 到期警告天数               | int sp_warn     |
   | 账户不活动之前尚余天数     | int sp_inact    |
   | 账户到期天数               | int sp_expire   |
   | 保留                       | unsigned int sp_flag |
   
   一组类似的函数访问阴影口令文件。
   
   #include <shadow.h>
   struct spwd *getspnam(const char *name);
   struct spwd *getspent(void);
   void setspent(void);
   void endspent(void);
   
   mac没有阴影口令文件，类似的参考/etc/master.passwd
** 组文件
   /etc/group文件中的字段
   | 说明                     | struct group成员 |
   |--------------------------+------------------|
   | 组名                     | char *gr_name    |
   | 加密口令                 | char *gr_passwd  |
   | 数值组ID                 | int gr_gid       |
   | 指向各用户名的指针的数组 | char **gr_mem   |
   
   查看数组名或数值组ID
   #include <grp.h>
   struct group *getgrgid(gid_t gid);
   struct group *getgrnam(const char *name);

   
   搜索整个组文件函数
   #include <grp.h>
   struct group *getgrent(void);
   void setgrent(void);
   void endgrent(void);

** 附加组ID
   口令newgrp可以更改组id。
   
   为了获取和设置附加组ID,提供了下列三个函数：
   #include <unistd.h>
   int getgroups(int gidsetsize, gid_t grouplist[]);
   
   #include <grp.h> /* on linux */
   #include <unistd.h> /* on freebsd, mac os x , amd solaris */
   int setgroups(int ngroups, const gid_t grouplist[]);

   #include <grp.h> /* on linux and solaris */
   #include <unistd.h> /* on freebsd and mac os x */
   int initgroups(const char *username, gid_t basegid);
** 实现的区别

** 其他数据文件
   存取系统数据文件的类似例程 
   | 说明 | 头文件     | 数据文件       | 结构     | 附加的关键字查找函数             |
   |------+------------+----------------+----------+----------------------------------|
   | 口令 | <pwd.h>    | /etc/passwd    | passwd   | getpwnam、getpwuid               |
   | 组   | <grp.h>    | /etc/group     | group    | getgrname、getgrgid              |
   | 阴影 | <shadow.h> | /etc/shadow    | spwd     | getspnam                         |
   | 主机 | <netdb.h>  | /etc/hosts     | hostent  | gethostbyname、gethostbyaddr     |
   | 网络 | <netdb.h>  | /etc/networks  | netent   | getnetbyname、getnetbyaddr       |
   | 协议 | <netdb.h>  | /etc/protocols | protoent | getprotobyname、getprotobynumber |
   | 服务 | <netdb.h>  | /etc/services  | servent  | getservbyname、getservbyport      |
  
** 登录账户记录
   大多数UNIX系统都提供下列两个数据文件：
   1. utmp文件，记录当前登录进系统的各个用户。
   2. wtmp文件，跟踪各个登录和注销事件。

   struct utmp {
       char ut_line[8]; /* tty line : "ttyh0", "ttyd0" ... */
       char ut_name[8];/ login name */
       long ut_time; /* seconds since Epoch */

   }
   
   登录时，login程序填写此类结构，然后写入utmp文件，同时添加至wtmp文件。
   注销时，init进程将utmp相应的记录擦除，并将一个新记录添加到wtmp文件。
   
   who程序读取utmp文件。 last程序读取wtmp文件。
** 系统标识
   uname函数。
   #include <sys/utsname.h>
   int uname(struct utsname *name);
   
   struct utsname {
       char sysname[];/* name of operating system */
       char nodename[]; /* name of this node */
       char release[]; /*current release of operating system */
       char version[]; /* current version of this release*/
       char machine[]; /* name of hardware type*/
   }
   
   gethostname获取TCP/IP网络上主机的名字。
   #include <unistd.h>
   int gethostname(char *name, int namelen);
   主机名的最大名字长度 HOST_NAME_MAX。

   hostname 用于获取和设置主机名。
** 时间和日期例程
   日历时间包括日期和时间。
   UNIX在这方面与其他操作系统的区别是：
   1. 以国际标准时间而非本地时间计时；
   2. 可自动进行转换，例如变换到夏时制
   3. 将时间和日期作为一个量值保存。
      

   time函数返回当时时间和日期
   #include <time.h>
   time_t time(time_t *calptr);
   
   在BSD派生的系统中，调用settimeofday,用于对内核中的当前时间设置初始值。
   #include <sys/time.h>
   int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
   tzp的唯一合法值是NULL,其他值则将产生不确定的结果。

   struct timeval{
       time_t tv_sec;
       long tv_usec;
   }
   
   localtime和gmtime把time_t转成tm结构，tm结构包括年、月、日、时、分、秒、周日等。
   struct tm{ /* a broken-down time */
       int tm_sec; /* seconds after the minute:[0-60]*/
       int tm_min; /* minutes after the hour: [0-59] */
       int tm_hour:/* hours after midnight: [0-23] */
       int tm_day: /* day of the month */
       int tm_mon; /* months since January: [0-11] */
       int tm_year; /* years sinsce 1900 */
       int tm_wday; /* days since Sunday:[0-6] */
       int tm_yday; /* days since January 1: [0-365]*/
       int tm_isdst; /* daylight saving time flag: <0, 0, >0 */
   }
   
   秒可以越过59的理由是可以表示润秒。
   **闰秒（或称跳秒）是对UTC(协调世界时)作出加一秒或减一秒的调整，用来协调不均匀的地球自转时间与原子时间之间的差值不超过0.9秒。**

   #include <time.h>
   struct tm *gmtime(const time_t *calptr);/*转成国际标准时*/
   struct tm *localtime(const time_t *calptr);/*转成本地时间,受TZ影响*/
   
   #include <time.h>
   time_t mktime(struct tm *tmptr);/*转成日历时间, tmptr是本地时间,受TZ影响*/
   
   #include <time.h>
   char *asctime(const struct tm *tmptr);/*把tm结构的时间转成字符串时间*/
   char *ctime(const time_t *calptr);/*把日历时间转成字符串时间,受TZ影响*/
   
   #include <time.h>
   size_t strftime(char *restrict buf, size_t maxsize, const char *restrict format, const struct tm *restrict tmptr);/*格式化时间,受TZ影响*/
   
   第一周有不同的定义：
   * %U, 包含该年第一个星期日的周为第一周。
   * %W，包含该年第一个星期一的周为第一周。
   * %V, 若某周包含了1月1日，而且至少包含了其后的另外3天，那么该周是一年的中第一周，否则该周被认为是上一年的最后一周。(周一被视为每周的第一天)
     
* 进程环境
** main函数
   int main(int argc, char *argv[]);

   当内核执行C程序时(使用一个exec函数), 在调用main函数前先调用一个特殊的启动例程。
   可执行程序文件将此启动例程指定为程序的起始地址--这是由连接编译器设置的，而连接编译器则由C编译器调用。
   启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。
   **启动例程是啥?**
   需要用到编译原理
   gcc main.o -o main 其实是类似调用的
   ld /usr/lib/crt1.o /usr/lib/crti.o main.o -o main -lc -dynamic-linker /lib/ld-linux.so.2
   启用例程便是指的/usr/lib/ctr1.o中的start函数。
** 进程终止
   5种正常终止
   1. 从main返回。
   2. 调用exit
   3. 调用_exit或_Exit。
   4. 最后一个线程从其启动例程返回。
   5. 最后一个线程调用pthread_exit

   3种异常终止
   1. 调用abort
   2. 接到一个信号并终止
   3. 最后一个线程对取消请求做出响应
      
   启动例程调用：
   exit(main(argc,argv));

*** exit函数
    有3个函数用于正常终止程序：_exit和_Exit立即进入内核,exit则先执行一些清理处理(包括调用执行各终止处理程序，关闭所有标准I/O流等），然后进入内核。
    #include <stdlib.h>
    void exit(int status);
    void _Exit(int status);
    
    #include <unistd.h>
    void _exit(int status);
    
    以下三种情况，进程的终止状态是未定义的：
    1. 调用这些函数时(以上3个），不带终止状态。
    2. main执行了一个无返回值的return语句。
    3. main没有声明返回类型为整形。
    
*** atexit函数
    上文提到exit会执行一些清理操作，这些清理操作是由atexit登录的，按ISO C的规定，一个进程可以登记多达32个函数。
    这些程序称为终止处理程序。
    #include <stdlib.c>
    int atexit(void (*func)(void));
    
    exit调用这些函数的顺序与登记顺序相反。同一函数如若登记多次，也地调用多次。
    
    根据ISO C和POSIX.1, exit首先调用各终止处理程序，然后按需多次调用fclose，关闭所有打开流。
    POSIX.1扩展了ISO C标准，它指定如若程序调用exec函数族中的任一函数，则将清除所有已安装的终止处理程序。

    内核使程序执行的唯一入口是调用一个exec函数。
    进程自愿终止的唯一方法是显示或隐式地调用_exit或_Exit。
    
** 命令行参数
   调用exec的进程可将命令行参数传递给该新程序，这是UNIX SHELL的一部分常规操作。
** 环境表
   每个程序都会接收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以null结束的C字符串的地址，内容为key=value的形式。
   全局变量environ包含了该指针的地址：
   extern char **environ;
   通常使用getenv和putenv函数来访问特定的环境变量，而不是用environ变量。但是，如果要查看整个环境，则必须使用environ指针。
** C程序的存储空间布局
   从历史上讲，C程序一直由下面几部分组成：
   1. 正文段。这是由CPU执行的机器指令部分。通常，正文段是可共享的。
   2. 初始化数据段。通常称此段为数据段，它包含了程序中需明确地赋初值的变量。
   3. 非初始化数据段。通常称此段为bss段。在程序开始执行之前，内核将此段中的数据初始化为0或空指针。
   4. 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。
      每次调用函数时，其返回地址以及调用者的环境信息（例如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。
      通过这种方式使用栈，可以递归调用C函数。
      递归函数每次调用自身时，就使用一个新的栈帧，因此一个函数调用实例中的变量集不会影响到另一个函数调用实例中的变量。
      **栈帧的结构是怎么样的?**
      从逻辑上讲，栈帧就是一个函数执行时环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。
      实现上有硬件方式和软件方式。

   5. 堆。通常在堆中进行动态存储分配。
      
   在linux上典型的安装方式是: 从高地址到低地址依次是 命令行参数和环境变量->栈(栈从高地址向低地址方向增长)->虚地址空间->堆->未初始化数据->初始化数据->正文。
   
   size命令可以报告正文段、数据段和bss段的长度。
** 共享库
   共享库使得可执行文件中不再需要包含公用的库例程，而只需在所有进程都可引用的存储区中维护这种库例程的一个副本。
   程序第一次执行或第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。
   这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。
   共享库的另一个优点是可以用库函数的新版本代替老版本，而无需对使用该库的程序重新连接编辑。
** 存储器分配
   3个动态分配函数：
   1. malloc. 分配指定字节数的存储区。此存储区中的初始值不确定。
   2. calloc. 为指定数据 具指定长度的对象 分配存储空间。该空间中的每一位都初始化为0.
   3. realloc. 更改以前分配的长度(增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。
      
    
   #include <stdlib.h>
   void *malloc(size_t size);
   void *calloc(size_t nobj, size_t size);
   void *realloc(void *ptr, size_t newsize);

   void free(void *ptr);
   
   这3个分配函数所返回的值一定是适当对齐的，使其可用于任何数据对象。
   函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池。
   因为realloc分配的存储区可能会移动位置，所以不应当使任何指针指到该区中。

   这些分配例程通常用sbrk系统调用实现。该系统调用扩大（或缩小）进程的堆。
   虽然sbrk可以扩大或缩小进程的存储空间，但是大多数malloc和free的实现都不减小进程的存储空间。释放的空间可供以后再分配，但通常将它们保持在malloc池中而不返回给内核。
   
   应当注意的是，大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息--分配块的长度、指向下一个分配块的指针等等。
   产生致命性的错误有：
   1. 在动态分配的缓冲区前或后进行写操作。
   2. 释放一个已经释放的块。
   3. 调用free时所用的指针不是三个alloc函数的返回值。
      

   若一个进程调用了malloc函数，但去忘记调用free函数，那么该进程占用的存储器就会连续增加，这被称为泄露。
   为了防止错误使用存储分配器函数。提供了以下替换库：
   1. libmalloc
   2. vmalloc
   3. 快速适配
   4. alloca函数

** 环境变量
   #include <stdlib.h>
   char *getenv(const char *name);
   此函数返回一个指针，它指向name=value字符串中的value。注意，环境表中，指针数组批向的其实是name=value的字符串。
   Single UNIX Specification定义的环境变量
   | 变量        | 说明                           |
   |-------------+--------------------------------|
   | COLUMNS     | 终端宽度                       |
   | DATEMSK     | getdate(3)模块文件路径名       |
   | HOME        | 起始目录                       |
   | LANG        | 本地名                         |
   | LC_ALL      | 本地名                         |
   | LC_COLLATE  | 本地排序名                     |
   | LC_CTYPE    | 本地字符分类名                 |
   | LC_MESSAGES | 本地消息名                     |
   | LC_MONETARY | 本地货币编辑名                 |
   | LC_NUMERIC  | 本地数字编辑名                 |
   | LC_TIME     | 本地日期/时间格式名            |
   | LINES       | 终端高度                       |
   | LOGNAME     | 登录名                         |
   | MSGVERB     | fmtmsg(3)处理的消息组成部分    |
   | NLSPATH     | 消息类模板序列                 |
   | PATH        | 搜索可执行文件的路径前缀列表   |
   | PWD         | 当前工作目录的绝对路径名       |
   | SHELL       | 用户首选的shell名              |
   | TERM        | 终端类型                       |
   | TMPDIR      | 在其中创建临时文件的目录路径名 |
   | TZ          | 时区信息                       |
   |-------------+--------------------------------|
   
   命令ENV可以查看环境变量。
   我们也能设置环境变量的值。我们能影响的只是当前进程及调用的任何子进程的环境，但不能影响父进程的环境，这通常是一个shell进程。


   #include <stdlib.h>
   int putenv(char *str);
   
   int setenv(const char *name, const char *value, int rewrite);
   int unsetenv(const char *name);
   由于环境表和环境字符串通常存放在进程存储空间的顶部。它既不能向高地址扩展，也不能向低地址扩展。
   在修改或新增时比较麻烦。在空间不够时，需要用malloc在堆申请内存空间，然后把整个环境表copy到堆。但原来的name=value还是在存储空间的顶部。这样就会是两个存储空间的混合使用。
   可见增加环境变量的效率不会高。
** setjmp和longjmp函数
   非局部指的是，这不是由普通C语言goto语句在一个函数内实施的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中。
   #include <setjmp.h>
   int setjmp(jmp_buf env);
   
   void longjmp(jmp_buf env, int val);

   规范的使用方式是将env变量定义为全局变量。
   
   对于一个setjmp,可以有多个longjmp。val用来区分从哪调用的longjmp。
   
   调用longjmp造成main中的setjmp的返回，但是这一次的返回值是longjmp的第二个参数。
*** 自动、寄存器和易失变量
    当longjmp返回到setjmp时(上例是main), 自动变量和寄存器变量的值是否会恢复到以前调用setjmp时的值，或者保持为调用longjmp时的值？
    答案是“看情况”。大多数实现并不回滚这些自动变量和寄存器变量的值，而所有标准则说它们的值是不确定的。

    如果你有一个自动变量，而又不想使其值回滚，则可定义为具有volatile属性。
    声明为全局或静态变量的值在执行longjmp时保持不变。
    **C语言volatile**
    用于告诉编译器这个变量是容易变化的，不需要优化(如使用寄存器优化)，每次用的时候，直接从原内存中读取。避免寄存器、CPU高级缓存等导致的数据不一致性。
    
    如果要编写一个使用非局部跳转的可移植程序，则必须使用volatile属性。但是从一个系统移植到另一个系统，任何事情都可能改变。
*** 自动变量的潜在问题
    声明自动变量的函数返回后，不能再使用这些自动变量。
** getrlimit和setrlimit函数
   每个进程都有一组资源限制，其中一些可以用getrlimit和setrlimit函数查询和更改。
   #include <sys/resource.h>
   int getrlimit(int resource, struct rlimit *rlptr);
   int setrlimit(int resource, const struct rlimit *rlptr);
   
   进程的资源限制通常是在系统初始化时由进程0建立的，然后由每个后续进程继承。
   struct rlimit{
       rlim_t rlim_cur;/* soft limit ,current limit */
       rlim_t rlim_max;/* hard limit: maximum value for rlim_cur */
   }
   
   在更改资源限制时，须遵循下列三条规则：
   1. 任何一个进程都可将一个软限制值更改为小于或等于其硬限制值。
   2. 任何一个进程都可降低其硬限制值，但它必须>=其软限制值。这种降低对普通用户而言是不可逆的。
   3. 只有超级用户进程可以提高硬限制值。
   
      
   资源限制
   | 限制           | 说明                                                                                  |
   |----------------+---------------------------------------------------------------------------------------|
   | RLIMIT_AS      | 进程可用存储区的最大总长度。这会影响sbrk函数和mmap函数                                |
   | RLIMIT_CORE    | core文件的最大字节数，若其值为0则阻止创建core文件。                                   |
   | RLIMIT_CPU     | CPU时间的最大量值(秒),当超过此软限制时，向该进程发送SIGXCPU信号。                     |
   | RLIMIT_DATA    | 数据段的最大字节长度。是初始化的数据+未初始化数据+堆                                  |
   | RLIMIT_FSIZE   | 可以创建的文件的最大字节长度。当超过此软限制时，则向该进程发送SIGXFSZ信号             |
   | RLIMIT_LOCKS   | 一个进程可持有的文件锁的最大数                                                        |
   | RLIMIT_MEMLOCK | 一个进程使用mlock(2)能够锁定在存储器中的最大字节长度。                                |
   | RLIMIT_NOFILE  | 每个进程能打开的最大文件数。更改此限制将影响到sysconf函数在参数_SC_OPEN_MAX中返回的值 |
   | RLIMIT_RSS     | 最大驻内存集的字节长度。如果物理存储器供不应求，则内核将从进程处取回超过RSS的部分。   |
   | RLIMIT_SBSIZE  | 用户在任一给定时刻可以占用的套接字缓冲区的最大长度(字节)。                            |
   | RLIMIT_STACK   | 栈的最大字节长度。                                                                    |
   | RLIMIT_VMEM    | 这是RLIMIT_AS的同意词                                                                 |

   ulimit命令可以查看和设置。
   **什么是core文件?**
   当程序crash时，操作系统会把程序Down掉时的内存拷贝一分到core文件，供分析使用。
   
* 进程控制
** 进程标识符
   每个进程都有一个非负整型表示的唯一进程ID。因为是唯一的，常将其用作其他标识符的一部分以保证其唯一性。
   虽然是唯一的，但是进程ID可以重用。
   大多数UNIX系统实现延迟重用算法， 使得赋予新建进程的ID不同于最近终止进程所使用的ID。

   系统专用进程：
   1. 进程0, 调度进程，也叫交换进程,也叫系统进程。是内核的一部分，它并不执行任何磁盘上的程序。
   2. 进程1, init进程，是用户进程，但是由超级用户特权执行，是所有孤儿进程的父进程。在自举过程结束后由内核调用。程序文件是/etc/init, 较新版本是/sbin/init。
      此进程负责在自举内核后启动一个UNIX系统。init通常读与系统有关的初始化文件(/etc/rc*文件或/etc/inittab文件，以及/etc/init.d中的文件),并将系统引导到一个状态，init进程绝不会终止。
   3. 进程2, 页守护进程。负责支持虚拟存储系统的分页操作。
      
      
   #include <unistd.h>
   pid_t getpid(void);
   pid_t getppid(void);

   uid_t getuid(void);
   uid_t geteuid(void);
   gid_t getgid(void);
   gid_t etegid(void);

** fork函数
   创建新进程
   #include <unistd.h>
   pid_t fork(void);

   fork函数被调用一次，但返回两次。对父进程返回子进程ID, 对子进程返回0.
   
   子进程获得父进程数据空间、堆和栈的副本。父子进程并不共享这些存储空间部分，父、子进程共享正文段。
   
   由于在fork之后经常跟随着exec,所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。
   作为替代，使用了写时复制技术。
   这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统中的一“页”。

   一般来说，在fork之后是父进程还是子进程执行是不确定的。

   strlen和sizeof的区别：
   1. strlen会计算不包含终止null字节的字符串长度。sizeof会包含null
   2. strlen有一次函数调用。sizeof在编译时确定了缓冲区长度。只是针对char buf[] = "hello",这样的声明。
      
*** 文件共享
    fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。父子进程的每个相同的打开描述符共享一个文件表项。
    这种共享文件的方式使父、子进程对同一个文件使用了一个文件偏移量。


    在fork之后处理文件描述符有两种常见的情况：
    1. 父进程等待子进程完成。不需要特殊处理。因为共享文件表项。
    2. 父、子进程各自执行不同的程序段。在这种情况下，父、子进程各自关闭它们不需要使用的文件描述符，这样就不会干扰对方使用的文件描述符。
       这种方法就是网络服务进程中经常使用的。

       
    除了打开文件之外，父进程的很多其他属性也由子进程继承，包括
    * 实际用户ID、实际组ID、有效用户ID、有效组ID、附加组ID
    * 进程组ID
    * 会话ID
    * 控制终端
    * 设置用户ID标志和设置组ID标志
    * 当前工作目录
    * 根目录
    * 文件模式创建屏蔽字
    * 信号屏蔽和安排
    * 针对任一打开文件描述符的在执行时关闭(close-on-exec)标志。
    * 环境。
    * 连接的共享存储段。
    * 存储映射。
    * 资源限制.

     
    父、子进程之间的区别是：
    * fork的返回值。
    * 进程ID不同
    * 两个进程具有不同的父进程ID
    * 子进程的tms_utime、tms_stime、tms_cutime以及tms_ustime均被设置为0。
    * 父进程设置的文件锁不会被子进程继承。
    * 子进程的未处理的闹钟(alarm)被清除。
    * 子进程的未处理信号集设置为空集。
    
    
    使fork失败的两个主要原因是：
    1. 系统中已经有了太多的进程。
    2. 该实际用户ID的进程总数超过了系统限制。

       
    fork有下面两种用法：
    1. 一个父进程希望复制自己，使父、子进程同时执行不同的代码段。在网络服务进程中常见。
    2. 一个进程要执行一个不同的程序。shell中常见。

       
    某些操作系统会把fork和exec组合成一个，并称其为spawn。
    分开的好处是：
    1. 很多场合需要单独使用fork,其后不跟随exec
    2. 在fork和exec之间可以更改自己的属性，如I/O重定向、用户ID、信号安排等。
** vfork函数
   vfork已被标记为废弃接口，和fork的第2个用法的目的相同，是为了exec一个新程序。
   区别：
   1. vfork创建的子进程，并不将父进程的地址空间完全复制到子进程中，在调用exec或exit之前，是在父进程的地址空间中运行。
   2. vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度执行(如果在调用这两个函数之前子进程依赖父进程的进一步动作，则会导致死锁)。
   
** exit函数
   不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器。
   正常终止的情况，传参给exit、_exit和_Exit 可以把 **退出状态** 传递给父进程。
   异常终止的情况，内核会产生一个指示异常终止原因的 **终止状态** 。之后父进程可以通过调用wait或waitpid函数取得其终止状态。
   
   两种情况：
   1. 父进程比子进程先死，子进程的父进程会自动变更为init进程。
      >在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则将该进程的父进程ID更改为1。
   2. 子进程比父进程先死，内枋为每个终止子进程保存了一定量的信息，当父进程调用wait或waitpid时，可以得到这些信息。
      >这些信息至少包括进程ID、该进程的终止状态、以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。

      
   一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息，释放它仍占用的资源）的进程被称为僵死进程。
   ps（1）命令将僵死进程的状态打印为Z。
   


   init进程被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中有很多僵死进程。

** wait和waitpid函数
   当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号(signal child?)。这个信号是个异步信号，父进程接收到后可以选择忽略，也可以提供一个信号处理函数来处理。系统的默认处理是忽略。
   调用wait或waitpid可能发生的情况：
   1. 如果其所有子进程都还在运行，则阻塞。
   2. 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。
   3. 如果它没有任何子进程，则立即出错返回。

      
   如果进程由于接收到SIGCHLD信号而调用wait,则可期望wait会立即返回。

   #include <sys/wait.h>
   pid_t wait(int *statloc);
   pid_t waitpid(pid_t pid, int *statloc, int options);
   
   区别如下：
   1. 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞。
   2. waitpid并不等待在其调用之后的第一个终止进程，它有若干个选项，可以控制它所等待的进程。

      
   状态字是由实现定义的。某些位表示退出状态，其他位则指示信号编号(异常返回),有一位指示是否产生了core文件等。
   POSIX.1规定终止状态用定义在<sys/wait.h>中的各个宏来查看。如下表所示

   | 宏                   | 说明                                                                                                                    |
   |----------------------+-------------------------------------------------------------------------------------------------------------------------|
   | WIFEXITED(status)    | 若为正常终止子进程返回的状态，则为真。对于这种情况可执行WEXITSTATUS(status),取子进程传送给exit、_exit、_Exit参数的低8位 |
   | WIFSIGNALED(status)  | 若为异常终止子进程返回的状态，则为直。对于这种情况，可执行WTERMSIG(status),取使子进程终止的信号编号。另外，有些实现定义 |
   |                      | 宏WCOREDUMP(status),若已产生终止进程的core文件，则它返回真。                                                            |
   | WIFSTOPPED(status)   | 若为当前暂停子进程的返回的状态，则为真。对于这种情况，可执行WSTOPSIG(status),取使子进程暂停的信号编号。                 |
   | WIFCONTINUED(status) | 若在作业控制暂停后已经继续的子进程返回了状态，则为真。                                                                                             |
   
   **暂停的进程也可以通过wait拿到状态?**

** waitid函数
** wait3和wait4函数
** 竞争条件
** exec函数
** 更改用户ID和组ID
** 解释器文件
** system函数
** 进程会计
** 用户标识
** 进程时间

  stop一下，在这里复习前面8章内容。
* 进程关系