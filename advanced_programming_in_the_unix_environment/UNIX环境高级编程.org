* 第一章 UNIX基础知识
操作系统有两个含义：
1. 仅指内核，它控制计算机硬件资源，提供程序运行环境。
2. 广义上，包括内核和一些其它软件，如系统实用程序、应用软件、shell以及公用函数库等。 
** 文件与目录
   UNIX文件系统的大多数实现并不在目录项中存放属性。有inode就够。

   程序的正确性是由硬件->内核->系统调用->标准库函数->第三方库->程序员 逐步保证的。
** 程序与进程
   程序是存放在磁盘上，处于某个目录中的一个可执行文件。使用6个exec函数中的一个由内核将程序读入存储器，并使其执行。
   
   有三个用于进程控制的主要函数：fork、exec和waitpid。
*** 线程和线程ID
    通常，一个进程只有一个控制线程，同一时刻只执行一组机器指令。
    在一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。
** 出错处理
   当UNIX函数出错时，一般返回一个负值，而且整型变量errno通常被设置为含有附加信息的一个值。
   返回一个指向对象指针的大多数函数，在出错时，将返回一个null指针。

   POSIX和ISO C将errno定义为这样一个符号，它扩展成为一个可修改的整型左值(lvalue)。这可以是包含出错编号的一个函数，或者是一个返回出错编号指针的函数。
   extern int * __errno_location(void);
   #define errno (*__errno_location())
   在支持多线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno以避免一个线程干扰另一个线程。
   对于errno应当知道两条规则：
   1. 如果没有出错，则其值不会被一个例程清除。因为，仅当函数的返回值指明出错时，才检验其值。
   2. 任一函数都不会将errno值设为0,在<errno.h>中定义的所有常量都不为0。
 
** 用户标识
   对于权限，使用数值用户ID和数值值ID是历史上形成的。1是数字比字符串的存储空间小,每个文件都会存放用户ID和组ID;2是查验权限期间，比较整数更快。
   
** 信号
   信号是通知进程已发生某种情况的一种技术。

   进程处理信息有三种选择：
   1. 忽略信号。
   2. 按系统默认方式处理。
   3. 提供一个信号捕捉函数，自定义处理。

   在键盘上产生信号的办法,中断键盘(Ctrl+C)和退出键(Ctrl+\)。
   
** 时间值
   长期以来，UNIX系统一直使用两种不同的时间值。
   1. 日历时间。自1970年1月1日00:00:00以来UTC所经过的秒数。
   2. 进程时间。也被称为CPU时间，用来度量进程使用的中央处理器资源。
      1. 时针时间
      2. 用户CPU时间
      3. 系统CPU时间。


* 第二章 UNIX标准化及实现
** UNIX标准化
   所有标准化工作的一个重要部分是对每种实现必须定义的各种限制进行说明。
  名词解释:
  ISO(International Organization for Standardization), 国际标准化组织。
  IEC(International Electrotechnical Commission),国际电子技术委员会。
  IEEE(Institude of Electrical and Electronics Engineers), 电气与电子工程师协会。
  POSIX(Portable Operating System Interface), 可移植的操作系统接口。
  Single UNIX Specification, 单一UNIX规范。

*** ISO C
    ISO C标准的意图是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不只是UNIX系统。
    此标准不仅定义了C程序设计语言的语法和语义，还定义了其标准库。
    
    ISO C标准定义的头文件(24个区)
    | 头文件       | FreeBSD5.2.1 | Linux2.4.22 | Mac OS X 10.3 | Solaris9 | 说明                     |
    | <assert.h>   | *            | *           | *             | *        | 验证程序断言             |
    | <complex.h>  | *            | *           | *             |          | 支持复数算术运算         |
    | <ctypes.h>   | *            | *           | *             | *        | 字符类型                 |
    | <errno.h>    | *            | *           | *             | *        | 出错码                   |
    | <fenv.h>     |              | *           | *             | *        | 浮点环境                 |
    | <float.h>    | *            | *           | *             | *        | 浮点常量                 |
    | <inttypes.h> | *            | *           | *             | *        | 整形格式转换             |
    | <iso646.h>   | *            | *           | *             | *        | 替代关系操作符宏         |
    | <limits.h>   | *            | *           | *             | *        | 实现常量                 |
    | <locale.h>   | *            | *           | *             | *        | 局部类别                 |
    | <math.h>     | *            | *           | *             | *        | 数学常量                 |
    | <setjmp.h>   | *            | *           | *             | *        | 非局部goto               |
    | <signal.h>   | *            | *           | *             | *        | 信号                     |
    | <stdarg.h>   | *            | *           | *             | *        | 可变参数表               |
    | <stdbool.h>  | *            | *           | *             | *        | 布尔类型和值             |
    | <stddef.h>   | *            | *           | *             | *        | 标准定义                 |
    | <stdint.h>   | *            | *           | *             |          | 整形                     |
    | <stdio.h>    | *            | *           | *             | *        | 标准IO库                 |
    | <stdlib.h>   | *            | *           | *             | *        | 实用程序函数             |
    | <string.h>   | *            | *           | *             | *        | 字符串操作               |
    | <tgmath.h>   |              | *           |               |          | 通用类型数学宏           |
    | <time.h>     | *            | *           | *             | *        | 时间和日期               |
    | <wchar.h>    | *            | *           | *             | *        | 扩展的多字节和宽字符支持 |
    | <wctype.h>   | *            | *           | *             | *        | 宽字符分类和映射支持     |
    
*** IEEE POSIX
    可移植的操作系统接口，原来指的是操作系统接口，后来扩展成包括很多标记为1003的标准及标准草案，包括shell和实用程序。
* 第三章 文件I/O
** 引言
   UNIX系统中的大多数文件I/O只需要用到5个函数:open、read、write、lseek以及close。
   
   本章说明的函数经常被称为不带缓冲的I/O。术语 **不带缓冲** 指的是每个read和write都调用内核的一个系统调用。

   多个进程共享文件 相关的函数：dup、fcntl、sync、fsync和ioctl

** 文件描述符
   文件描述符的变化范围是0~OPEN_MAX。
** open函数

   #include <fcntl.h>
   int open(const char *pathname, int oflag, ... /* mode_t mode */);

   O_DSYNC和O_SYNC标志有微妙的区别。仅当文件属性需要更新以反映文件数据变化(例如，更新文件大小以反映文件中包含了更多的数据)时，O_DSYNC标志
   才影响文件属性。而设置O_SYNC标志后，数据和属性总是同步更新。当文件用O_DSYNC标志打开，在重写其现有的部分内容时，文件时间属性不会同步更新。与此相反，如果文件是用O_SYNC标志打开，那么对该文件的每一次
   write操作都将在write返回前更新文件时间, 这与是否改写现有字节或增写文件无关。
   
   由open返回的文件描述符一定是最小的未用描述符数值。
   
   若_POSIX_NNO_TRUNC有效，则在整个路径名超过PATH_MAX, 或路径名中任一文件名超过NAME_MAX时，返回出错状态，并将errno设置为ENAMETOOLONG。
   
** create函数

   #include <fcntl.h>
   int create(const char *pathname, mode_t mode);
   此函数等效于open(pathname, O_WRONLY | O_CREATE | O_TRUNC, mode);

** close函数
   
   #include <fcntl.h>
   int close(int filedes);

   关闭一个文件时还会释放该进程加在该文件上的所有 **记录锁**
   当一个进程终止时，内核自动关闭它所有打开的文件。

** lseek函数
   
   #include <fntl.h>
   off_t lseek(int filedes, off_t offset, int whence);

   可以用以下方式确认当前文件偏移量
   off_t currpos;
   currpos = lseek(fd,0,SEEK_CUR);

   这种方法也可以用来确定所涉及的文件是否可以设置偏移量。如果文件描述符引用的是一个管道、FIFO或网络套接字，则lseek返回-1,并将errno设置为ESPIPE。
   
   通常，文件的当前偏移量是一个非负整数，但是，某些设备也可能允许负的偏移量。但对于普通文件，则其偏移量必须是非负值 。因为偏移量可能是负值，所以在比较lseek的返回值时
   应当谨慎，不要测试它是否小于0，而是要测试它是否等于-1。

   lseek仅将当前文件的偏移量记录在内核中，它并不引起任何I/O操作。然后该偏移量用于下一个读/写操作。

   文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一一次写操作将加和该文件，并在文件中构成一个空洞。位于文件中但没有写过的字节都被 **读为0**
   
   文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘快，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。

** read函数

   #include <fntl.h>
   ssize_t read(int filedes, void *buf, size_t nbytes);

   有多种情况可使实际读到的字节数少于要求读的字节数:
   1. 读普通文件时，在读到的要求字节数之前已达到了文件尾端。
   2. 从终端设备读时，通常一次最多读一行。
   3. 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。
   4. 当从管道或从FIFO读时，如若管道包含的字节少地所需要的字节数，那么read将只返回实际可用的字节数。
   5. 当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录。
   6. 当某一信号造成中断，而已经读了部分数据量时。
      
** write函数

   #include <fcntl.h>
   ssize_t write(int filedes, const void *buf, size_t nbytes);
   返回值通常和nbytes相同，不相同则出错。
   出错的原因可能是:
   1. 磁盘满
   2. 超过了一个给定进程的文件长度限制
      
** I/O效率
   BUFFSIZE的选取，和块大小sb_blksize一致，最高效。
   操作系统检测到顺序读时，会采取某种预读技术(read ahead)

** 文件共享
   内核使用三种数据结构表示打开的文件:
   1. 每个进程在进程表中都有一个记录项，记录项中包含有一张打开文件描述符表，每个描述符占一项。与每个描述符相关联的是：
      1. 文件描述符标志(close_on_exit)。
      2. 指向一个文件表项的指针。
   2. 内核为所有打开文件维持一张文件表。每个文件表项包含：
      1. 文件状态标志
      2. 当前文件偏移量
      3. 指向该文件v节点表项的指针
   3. 每个打开文件都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作的函数的指针。对于大多数文件，v节点还包含了该文件的i节点。
      这些信息是在打开文件时从磁盘上读入内存的，所以所有关于文件的信息都是快速可供使用的。

   如果两个独立进程各自打开了同一个文件。打开该文件的每个进程都得到一个文件表项，但对一个给定的文件只有一个v节点表项。每个进程都有自己的文件表项的一个理由是：这种安排使每个进程都有它自己的对该文件的当前偏移量。
   
   可能有多个文件描述符项指向同一个文件表项。譬如dup,fork。
   
   文件描述符标志和文件状态标志在作用域方面的区别，前者只用于一个进程的一个文件描述符，而后者则适用于指向该文件表项的任何进程中的所有描述符。
   
   当多个进程写同一个文件时，可能产生预期不到的效果。解决办法，参考下面的原子操作的概念。

** 原子操作
*** 添写至一个文件
    任何一个需要多个函数调用的操作都不可能是原子操作，因为在两个函数调用之间，内核可能会临时挂起该进程。
    UNIX提供了O_APPEND标志，内核在写之前会将偏移量设置为文件尾端处，而不用调用lseek。
*** pread和pwrite函数
    把lseek和I/O读写捆绑成了原子操作。由内核提供。

    #include <unistd.h>
    ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);
    ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);
*** 创建一个文件
    open提供O_CREATE和O_EXCL选项。当同时指定这两个选项，而该文件又已经存在时，open将失败。
    一般而言，原子操作指的是由多步组成的操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤中的一个子集。
** dup和dup2函数
   这两个函数都可用来复制一个现存的文件描述符，返回的新文件描述符与参数fieldes共享同一个文件表项。
   
   #include <unistd.h>
   int dup(int fieldes);
   int dup2(int fieldes, int fieldes2);

   复制一个描述符的另一种方法是fcntl函数。
   调用
   dup(filedes);
   等效于
   fcntl(filedes, F_DUPFD, 0)

   而调用
   dup2(filedes, filedes2);
   等效于
   close(filedes);
   fcntl(filedes, F_DUPFD, filedes2);
   第二个有区别，主要在于一个是原子操作，另一个不是。
** sync、fsync和fdatasync函数
   传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。写->缓冲区->输出队列->队首时，实际的I/O操作。这种方式称为延迟写。
   
   延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度。当系统发和故障时，这种延迟可能造成文件更新内容的丢失。
   为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数。

   #include <unistd.h>
   int fsync(int filedes);
   int fdatasync(int filedes);

   void sync(void);
   
   sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。
   通过称为update的系统守护进程会周期性地(一般每隔30秒)调用sync函数。这就保证了定期冲写内核的块缓冲区。

   fsync会等待磁盘操作结束，适合数据库应用。
** fcntl函数
   - Note taken on [2016-04-05 Tue 06:56]
   
   #include <fcntl.h>
   int fcntl(int filedes, int cmd, ... /* int arg */);

   fcntl函数有5种功能：
   1. 复制一个现有的描述符(cmd = F_DUPFD)
   2. 获得/设置文件描述符标记(cmd = F_GETFD或F_SETFD)
   3. 获得/设置文件状态标志(cmd = F_GETFL或F_SETFL)
   4. 获得/设置异步I/O所有权(cmd = F_GETOWN或F_SETOWN)
   5. 获得/设置记录锁(cmd = F_GETLK、F_SETLK或F_SETLK)
      
   由磁盘驱动器将队列数据写到磁盘上。
** ioctl函数
   ioctl函数是I/O操作的杂物箱。终端I/O是ioctl的最大使用方面。

   #include <unistd.h> /* System V */
   #include <sys/ioctl.h> /* BSD and linux */
   #include <stropts.h> /* XSI STREAMS */

   int ioctl(int filedes, int request, ... );
   
   每个设备驱动程序都可以定义它自己专用的一组ioctl命令。系统则为不同种类的设备提供通用的ioctl命令。
** /dev/fd
   打开文件/dev/fd/n 等效于复制描述符n。
   
   /dev/fd文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理其它路径名的相同方式处理标准输入和输出。
   
   filter file2 | cat file1 - file3 | lpr
   在命令行中用"-" 作为一个参数，特指标准输入或标准输出，这已由很多程序采用。但是这会带来一些问题，例如若用"-"指定第一个文件名，那么它看起来就像指定了命令行中的一个选项，/dev/fd则提高了文件名参数的一致性，也更加清晰。
* 第四章 文件和目录
** stat、fstat和lstat函数
   #include <sys/stat.h>
   int stat(const char *restrict pathname ,struct stat *restrict buf);
   int fstat(int filedes, struct stat *buf);
   int lstat(const char *restrict pathname, struct stat *restrict buf);
   
   restrict是C99引入，用来告诉编译器，指针是唯一操作对象的方式。
   如果pathname是符号链接，lstat返回的符号链接本身的有关信息，stat返回的是符号链接引用文件的信息。
   
   struct stat {
   mode_t st_mode;/* file type & mode */
   ino_t st_ino; /* i-node number */
   dev_t st_dev; /* device number (file system) */
   dev_t st_rdev; /* device number for special files*/
   nlink_t st_nlink; /* number of links */
   uid_t st_uid; /* user ID of owner */
   gid_t st_gid; /* group ID of owner */
   off_t st_size; /* size in bytes, for regular files */
   time_t st_atime;/* time of last access*/
   time_t st_mtime;/* time of last modification */
   time_t st_ctime; /* time of last file status change */
   blksize_t st_blksize; /* best I/O block size */
   blkcnt_t st_blocks; /* number of disk blocks allocated */
   }
** 文件类型
   文件类型有：
   1. 普通文件
   2. 目录文件
   3. 块特殊文件。这种文件类型提供对设备带缓冲的访问，每次访问以固定长度为单位进行。
   4. 字符特殊文件。不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。
   5. FIFO。用于进程间通信，也叫命名管道。
   6. 套接字，用于进程间网络通信，也可用于本机上进程间非网络通信。
   7. 符号链接
   
** 设置用户ID和设置组ID
   与每个进程相关的用户ID和组ID
   | 项目             | 说明                             |
   |------------------+----------------------------------|
   | 实际用户ID       | 我们实际上是谁                   |
   | 实际组ID         |                                  |
   | ----------       | -------------------------        |
   | 有效用户ID       | 用于文件访问权限检查             |
   | 有效组ID         |                                  |
   | 附加组ID         |                                  |
   | ----------       | -------------------------------- |
   | 保存的设置用户ID | 由exec函数保存                   |
   | 保存的设置组ID   |                                  |
   
   一般来说，有效用户ID就是实际用户ID,有效组ID就是实际组ID。但在文件模式字(st_mode)中有两个特殊标志。
   1. 设置用户ID, 当设置时，有效用户ID设置为文件所有者用户ID
   2. 设置组ID,当设置时，有效组ID设置为文件所有者组ID
   
** 文件访问权限
   目录的执行权限位被称为搜索位。
   
   对于目录的读权限和执行权限意义是不同的。读权限允许我们读目录，获得在该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，对该目录的执行权限使我们可以通过该
   目录(也就是搜索该目录，寻找一个特定的文件名)
   
   内核进行的文件访问权限测试：
   1. 若进程的有效用户ID是0，则允许访问。
   2. 若进程的有效用户ID等于文件所有者ID.那么，若所有者有权限，则允许。
   3. 若进程的有效组ID或进程有附加组ID之一等于文件的组ID,则依赖于组ID的权限位。
   4. 若其它用户适当的访问权限位被设置，则允许访问。

  说明：2,3,4按顺序检查时，如进程拥有此文件，则只检查第2步，3,4步不检查。其它情况类似。