* 第一章 UNIX基础知识
操作系统有两个含义：
1. 仅指内核，它控制计算机硬件资源，提供程序运行环境。
2. 广义上，包括内核和一些其它软件，如系统实用程序、应用软件、shell以及公用函数库等。 
** 文件与目录
   UNIX文件系统的大多数实现并不在目录项中存放属性。有inode就够。

   程序的正确性是由硬件->内核->系统调用->标准库函数->第三方库->程序员 逐步保证的。
** 程序与进程
   程序是存放在磁盘上，处于某个目录中的一个可执行文件。使用6个exec函数中的一个由内核将程序读入存储器，并使其执行。
   
   有三个用于进程控制的主要函数：fork、exec和waitpid。
*** 线程和线程ID
    通常，一个进程只有一个控制线程，同一时刻只执行一组机器指令。
    在一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。
** 出错处理
   当UNIX函数出错时，一般返回一个负值，而且整型变量errno通常被设置为含有附加信息的一个值。
   返回一个指向对象指针的大多数函数，在出错时，将返回一个null指针。

   POSIX和ISO C将errno定义为这样一个符号，它扩展成为一个可修改的整型左值(lvalue)。这可以是包含出错编号的一个函数，或者是一个返回出错编号指针的函数。
   extern int * __errno_location(void);
   #define errno (*__errno_location())
   在支持多线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno以避免一个线程干扰另一个线程。
   对于errno应当知道两条规则：
   1. 如果没有出错，则其值不会被一个例程清除。因此，仅当函数的返回值指明出错时，才检验其值。
   2. 任一函数都不会将errno值设为0,在<errno.h>中定义的所有常量都不为0。
 
** 用户标识
   对于权限，使用数值用户ID和数值值ID是历史上形成的。1是数字比字符串的存储空间小,每个文件都会存放用户ID和组ID;2是查验权限期间，比较整数更快。
   
** 信号
   信号是通知进程已发生某种情况的一种技术。

   进程处理信息有三种选择：
   1. 忽略信号。
   2. 按系统默认方式处理。
   3. 提供一个信号捕捉函数，自定义处理。

   在键盘上产生信号的办法,中断键盘(Ctrl+C)和退出键(Ctrl+\)。
   
** 时间值
   长期以来，UNIX系统一直使用两种不同的时间值。
   1. 日历时间。自1970年1月1日00:00:00以来UTC所经过的秒数。
   2. 进程时间。也被称为CPU时间，用来度量进程使用的中央处理器资源。
      1. 时钟时间
      2. 用户CPU时间
      3. 系统CPU时间。

* 第二章 UNIX标准化及实现
** UNIX标准化
   所有标准化工作的一个重要部分是对每种实现必须定义的各种限制进行说明。
  名词解释:
  ISO(International Organization for Standardization), 国际标准化组织。
  IEC(International Electrotechnical Commission),国际电子技术委员会。
  IEEE(Institude of Electrical and Electronics Engineers), 电气与电子工程师协会。
  POSIX(Portable Operating System Interface), 可移植的操作系统接口。
  Single UNIX Specification, 单一UNIX规范。
  ANSI C(American National Standards Institute),美国国家标准协会。

*** ISO C
    ISO C标准的意图是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不只是UNIX系统。
    此标准不仅定义了C程序设计语言的语法和语义，还定义了其标准库。
    
    ISO C标准定义的头文件(24个区)
    | 头文件       | FreeBSD5.2.1 | Linux2.4.22 | Mac OS X 10.3 | Solaris9 | 说明                     |
    | <assert.h>   | *            | *           | *             | *        | 验证程序断言             |
    | <complex.h>  | *            | *           | *             |          | 支持复数算术运算         |
    | <ctypes.h>   | *            | *           | *             | *        | 字符类型                 |
    | <errno.h>    | *            | *           | *             | *        | 出错码                   |
    | <fenv.h>     |              | *           | *             | *        | 浮点环境                 |
    | <float.h>    | *            | *           | *             | *        | 浮点常量                 |
    | <inttypes.h> | *            | *           | *             | *        | 整形格式转换             |
    | <iso646.h>   | *            | *           | *             | *        | 替代关系操作符宏         |
    | <limits.h>   | *            | *           | *             | *        | 实现常量                 |
    | <locale.h>   | *            | *           | *             | *        | 局部类别                 |
    | <math.h>     | *            | *           | *             | *        | 数学常量                 |
    | <setjmp.h>   | *            | *           | *             | *        | 非局部goto               |
    | <signal.h>   | *            | *           | *             | *        | 信号                     |
    | <stdarg.h>   | *            | *           | *             | *        | 可变参数表               |
    | <stdbool.h>  | *            | *           | *             | *        | 布尔类型和值             |
    | <stddef.h>   | *            | *           | *             | *        | 标准定义                 |
    | <stdint.h>   | *            | *           | *             |          | 整形                     |
    | <stdio.h>    | *            | *           | *             | *        | 标准IO库                 |
    | <stdlib.h>   | *            | *           | *             | *        | 实用程序函数             |
    | <string.h>   | *            | *           | *             | *        | 字符串操作               |
    | <tgmath.h>   |              | *           |               |          | 通用类型数学宏           |
    | <time.h>     | *            | *           | *             | *        | 时间和日期               |
    | <wchar.h>    | *            | *           | *             | *        | 扩展的多字节和宽字符支持 |
    | <wctype.h>   | *            | *           | *             | *        | 宽字符分类和映射支持     |
    
*** IEEE POSIX
    可移植的操作系统接口，原来指的是操作系统接口，后来扩展成包括很多标记为1003的标准及标准草案，包括shell和实用程序。
* 第三章 文件I/O
** 引言
   UNIX系统中的大多数文件I/O只需要用到5个函数:open、read、write、lseek以及close。
   
   本章说明的函数经常被称为不带缓冲的I/O。术语 **不带缓冲** 指的是每个read和write都调用内核的一个系统调用。

   多个进程共享文件 相关的函数：dup、fcntl、sync、fsync和ioctl

** 文件描述符
   文件描述符的变化范围是0~OPEN_MAX。
** open函数

   #include <fcntl.h>
   int open(const char *pathname, int oflag, ... /* mode_t mode */);

   O_DSYNC和O_SYNC标志有微妙的区别。仅当文件属性需要更新以反映文件数据变化(例如，更新文件大小以反映文件中包含了更多的数据)时，O_DSYNC标志
   才影响文件属性。而设置O_SYNC标志后，数据和属性总是同步更新。当文件用O_DSYNC标志打开，在重写其现有的部分内容时，文件时间属性不会同步更新。与此相反，如果文件是用O_SYNC标志打开，那么对该文件的每一次
   write操作都将在write返回前更新文件时间, 这与是否改写现有字节或增写文件无关。
   
   由open返回的文件描述符一定是最小的未用描述符数值。
   
   若_POSIX_NNO_TRUNC有效，则在整个路径名超过PATH_MAX, 或路径名中任一文件名超过NAME_MAX时，返回出错状态，并将errno设置为ENAMETOOLONG。
   
** create函数

   #include <fcntl.h>
   int create(const char *pathname, mode_t mode);
   此函数等效于open(pathname, O_WRONLY | O_CREATE | O_TRUNC, mode);

** close函数
   
   #include <fcntl.h>
   int close(int filedes);

   关闭一个文件时还会释放该进程加在该文件上的所有 **记录锁**
   当一个进程终止时，内核自动关闭它所有打开的文件。

** lseek函数
   
   #include <fntl.h>
   off_t lseek(int filedes, off_t offset, int whence);

   可以用以下方式确认当前文件偏移量
   off_t currpos;
   currpos = lseek(fd,0,SEEK_CUR);

   这种方法也可以用来确定所涉及的文件是否可以设置偏移量。如果文件描述符引用的是一个管道、FIFO或网络套接字，则lseek返回-1,并将errno设置为ESPIPE。
   
   通常，文件的当前偏移量是一个非负整数，但是，某些设备也可能允许负的偏移量。但对于普通文件，则其偏移量必须是非负值 。因为偏移量可能是负值，所以在比较lseek的返回值时
   应当谨慎，不要测试它是否小于0，而是要测试它是否等于-1。

   lseek仅将当前文件的偏移量记录在内核中，它并不引起任何I/O操作。然后该偏移量用于下一个读/写操作。

   文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写操作将加长该文件，并在文件中构成一个空洞。位于文件中但没有写过的字节都被 **读为0**
   
   文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘快，
   但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。

** read函数

   #include <fntl.h>
   ssize_t read(int filedes, void *buf, size_t nbytes);

   有多种情况可使实际读到的字节数少于要求读的字节数:
   1. 读普通文件时，在读到的要求字节数之前已达到了文件尾端。
   2. 从终端设备读时，通常一次最多读一行。
   3. 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。
   4. 当从管道或从FIFO读时，如若管道包含的字节少于所需要的字节数，那么read将只返回实际可用的字节数。
   5. 当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录。
   6. 当某一信号造成中断，而已经读了部分数据量时。
      
** write函数

   #include <fcntl.h>
   ssize_t write(int filedes, const void *buf, size_t nbytes);
   返回值通常和nbytes相同，不相同则出错。
   出错的原因可能是:
   1. 磁盘满
   2. 超过了一个给定进程的文件长度限制
      
** I/O效率
   BUFFSIZE的选取，和块大小sb_blksize一致，最高效。
   操作系统检测到顺序读时，会采取某种预读技术(read ahead)

** 文件共享
   内核使用三种数据结构表示打开的文件:
   1. 每个进程在进程表中都有一个记录项，记录项中包含有一张打开文件描述符表，每个描述符占一项。与每个描述符相关联的是：
      1. 文件描述符标志(close_on_exit)。
      2. 指向一个文件表项的指针。
   2. 内核为所有打开文件维持一张文件表。每个文件表项包含：
      1. 文件状态标志
      2. 当前文件偏移量
      3. 指向该文件v节点表项的指针
   3. 每个打开文件都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作的函数的指针。对于大多数文件，v节点还包含了该文件的i节点。
      这些信息是在打开文件时从磁盘上读入内存的，所以所有关于文件的信息都是快速可供使用的。

   如果两个独立进程各自打开了同一个文件。打开该文件的每个进程都得到一个文件表项，但对一个给定的文件只有一个v节点表项。
   每个进程都有自己的文件表项的一个理由是：这种安排使每个进程都有它自己的对该文件的当前偏移量。
   
   可能有多个文件描述符项指向同一个文件表项。譬如dup,fork。
   
   文件描述符标志和文件状态标志在作用域方面的区别，前者只用于一个进程的一个文件描述符，而后者则适用于指向该文件表项的任何进程中的所有描述符。
   
   当多个进程写同一个文件时，可能产生预期不到的效果。解决办法，参考下面的原子操作的概念。

** 原子操作
*** 添写至一个文件
    任何一个需要多个函数调用的操作都不可能是原子操作，因为在两个函数调用之间，内核可能会临时挂起该进程。
    UNIX提供了O_APPEND标志，内核在写之前会将偏移量设置为文件尾端处，而不用调用lseek。
*** pread和pwrite函数
    把lseek和I/O读写捆绑成了原子操作。由内核提供。

    #include <unistd.h>
    ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);
    ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);
*** 创建一个文件
    open提供O_CREATE和O_EXCL选项。当同时指定这两个选项，而该文件又已经存在时，open将失败。
    一般而言，原子操作指的是由多步组成的操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤中的一个子集。
   ** 内核是怎么实现的？当执行其中一个时，发生信号中断呢？或者两个语句中，第一个语句执行时间过长导致CPU时间片用完呢？**
** dup和dup2函数
   这两个函数都可用来复制一个现存的文件描述符，返回的新文件描述符与参数fieldes共享同一个文件表项。
   
   #include <unistd.h>
   int dup(int fieldes);
   int dup2(int fieldes, int fieldes2);
   
   由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。用dup2则可以用fieldes2参数指定新描述符的数值。如果filedes2已经打开，则先将其关闭。如若filedes等于filedes等于
   filedes2,则dup2返回filedes2,而不关闭它。

   复制一个描述符的另一种方法是fcntl函数。
   调用
   dup(filedes);
   等效于
   fcntl(filedes, F_DUPFD, 0)

   而调用
   dup2(filedes, filedes2);
   等效于
   close(filedes);
   fcntl(filedes, F_DUPFD, filedes2);
   第二个有区别，主要在于一个是原子操作，另一个不是。
** sync、fsync和fdatasync函数
   传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。写->缓冲区->输出队列->队首时，实际的I/O操作。这种方式称为延迟写。
   内核已经提供了缓冲机制，不过这个缓冲机制是为了减少频繁的I/O操作。
   之后说的标准I/O函数库的缓冲是指对系统调用的数据做了缓冲，这个缓冲的目的是为了减少系统调用次数。系统调用由于涉及到内核态和用户态的切换，是有一定的开销的。
   
   延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。
   为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数。

   #include <unistd.h>
   int fsync(int filedes);
   int fdatasync(int filedes);

   void sync(void);
   
   sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。
   通过称为update的系统守护进程会周期性地(一般每隔30秒)调用sync函数。这就保证了定期冲写内核的块缓冲区。

   fsync会等待磁盘操作结束，适合数据库应用。
** fcntl函数
   - Note taken on [2016-04-05 Tue 06:56]
   
   #include <fcntl.h>
   int fcntl(int filedes, int cmd, ... /* int arg */);

   fcntl函数有5种功能：
   1. 复制一个现有的描述符(cmd = F_DUPFD)
   2. 获得/设置文件描述符标记(cmd = F_GETFD或F_SETFD)
   3. 获得/设置文件状态标志(cmd = F_GETFL或F_SETFL)
   4. 获得/设置异步I/O所有权(cmd = F_GETOWN或F_SETOWN)
   5. 获得/设置记录锁(cmd = F_GETLK、F_SETLK或F_SETLW)
      
   由磁盘驱动器将队列数据写到磁盘上。
   在UNIX系统中，通常write只是将数据排入队列，而实际的写磁盘操作则可能在以后的某个时刻进行。
   程序运行时，设置O_SYNC标志会增加时钟时间(等待磁盘IO操作结束).
** ioctl函数
   ioctl函数是I/O操作的杂物箱。终端I/O是ioctl的最大使用方面。

   #include <unistd.h> /* System V */
   #include <sys/ioctl.h> /* BSD and linux */
   #include <stropts.h> /* XSI STREAMS */

   int ioctl(int filedes, int request, ... );
   
   每个设备驱动程序都可以定义它自己专用的一组ioctl命令。系统则为不同种类的设备提供通用的ioctl命令。
** /dev/fd
   打开文件/dev/fd/n 等效于复制描述符n。
   
   /dev/fd文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理其它路径名的相同方式处理标准输入和输出。
   
   filter file2 | cat file1 - file3 | lpr
   在命令行中用"-" 作为一个参数，特指标准输入或标准输出，这已由很多程序采用。但是这会带来一些问题，例如若用"-"指定第一个文件名，
   那么它看起来就像指定了命令行中的一个选项，/dev/fd则提高了文件名参数的一致性，也更加清晰。
* 第四章 文件和目录
** stat、fstat和lstat函数
   #include <sys/stat.h>
   int stat(const char *restrict pathname ,struct stat *restrict buf);
   int fstat(int filedes, struct stat *buf);
   int lstat(const char *restrict pathname, struct stat *restrict buf);
   
   restrict是C99引入，用来告诉编译器，指针是唯一操作对象的方式。
   如果pathname是符号链接，lstat返回的符号链接本身的有关信息，stat返回的是符号链接引用文件的信息。
   
   struct stat {
   mode_t st_mode;/* file type & mode */
   ino_t st_ino; /* i-node number */
   dev_t st_dev; /* device number (file system) */
   dev_t st_rdev; /* device number for special files*/
   nlink_t st_nlink; /* number of links */
   uid_t st_uid; /* user ID of owner */
   gid_t st_gid; /* group ID of owner */
   off_t st_size; /* size in bytes, for regular files */
   time_t st_atime;/* time of last access*/
   time_t st_mtime;/* time of last modification */
   time_t st_ctime; /* time of last file status change */
   blksize_t st_blksize; /* best I/O block size */
   blkcnt_t st_blocks; /* number of disk blocks allocated */
   }
** 文件类型
   文件类型有：
   1. 普通文件
   2. 目录文件
   3. 块特殊文件。这种文件类型提供对设备带缓冲的访问，每次访问以固定长度为单位进行。
   4. 字符特殊文件。不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。
   5. FIFO。用于进程间通信，也叫命名管道。
   6. 套接字，用于进程间网络通信，也可用于本机上进程间非网络通信。
   7. 符号链接
   
** 设置用户ID和设置组ID
   与每个进程相关的用户ID和组ID
   | 项目             | 说明                             |
   |------------------+----------------------------------|
   | 实际用户ID       | 我们实际上是谁                   |
   | 实际组ID         |                                  |
   | ----------       | -------------------------        |
   | 有效用户ID       | 用于文件访问权限检查             |
   | 有效组ID         |                                  |
   | 附加组ID         |                                  |
   | ----------       | -------------------------------- |
   | 保存的设置用户ID | 由exec函数保存                   |
   | 保存的设置组ID   |                                  |
   
   一般来说，有效用户ID就是实际用户ID,有效组ID就是实际组ID。但在文件模式字(st_mode)中有两个特殊标志。
   1. 设置用户ID, 当设置时，有效用户ID设置为文件所有者用户ID
   2. 设置组ID,当设置时，有效组ID设置为文件所有者组ID
   这两个设置过程是由exec操作的。
   
** 文件访问权限
   目录的执行权限位被称为搜索位。
   
   对于目录的读权限和执行权限意义是不同的。读权限允许我们读目录，获得在该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，
   对该目录的执行权限使我们可以通过该目录(也就是搜索该目录，寻找一个特定的文件名)
   
   内核进行的文件访问权限测试：
   1. 若进程的有效用户ID是0，则允许访问。
   2. 若进程的有效用户ID等于文件所有者ID.那么，若所有者有权限，则允许。
   3. 若进程的有效组ID或进程有附加组ID之一等于文件的组ID,则依赖于组ID的权限位。
   4. 若其它用户适当的访问权限位被设置，则允许访问。

   说明：2,3,4按顺序检查时，如进程拥有此文件，则只检查第2步，3,4步不检查。其它情况类似。
** 新文件和目录的所有权
   新文件的用户ID设置为进程的有效用户ID。
   关于组ID,有如下设定：
   1. 新文件的组ID可以是进程的有效组ID。
   2. 新文件的组ID可以是它所在目录的组ID。
   不同系统选择不一样，mac是第2个。
** access函数
   access函数是按实际用户ID和实际组ID进行访问权限测试的。

   #include <unistd.h>
   int access(const char *pathname, int mode);

   其中，mode是按下表按位或。
   | mode | 说明       |
   |------+------------|
   | R_OK | 测试读权限 |
   | W_OK | 测试写权限 |
   | X_OK | 测试执行权限 |
   | F_OK | 测试文件是否存在 |
** umask函数
   umask函数为进程设置文件模式创建屏蔽字，并返回以前的值。（少数几个没有出错返回函数中的一个)
   
   #include <sys/stat.h>
   mode_t umask(mode_t cmask);
   
   对于任何在文件模式创建屏蔽字中为1的位，在文件mode中的相应位则一定被关闭。
  
   在登录时，会由shell启动文件设置一次umask,然后就不变了。
   在编写创建新文件的程序时，如果要确保指定的访问权限位已激活，那么必须在进程运行时修改umask值。
   更改进程的文件模式创建屏蔽字并不影响父进程。
** chmod和fchmod函数
   
   #include <sys/stat.h>
   int chmod(const char *pathname, mode_t mode);
   int fchmod(int filedes, mode_t mode);

   为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID, 或者该进程必须有超级用户权限。
   
   chmod函数更新的只是i节点最近一次被更改的时间。
   
   设置用户ID和设置组ID由于安全原因。chmod有特殊处理, 在下列两个情况下会自动清除两个权限位。
   1. 在Solaris等系统上，如果设置普通文件的粘住位(S_ISVTX),而且又没有超级权限，那么mode中的粘住位将自动被关闭。
   2. 新创建文件的组ID可能不是调用进程所属的组(可能是父目录的组ID)。
   特别地，如果新文件的组ID不等于进程的有效组ID或者进程附加组ID中的一个，以及用户没有超级用户权限，那么设置组ID位将会自动被关闭。
** 粘住位
   历史技术，在UNIX还没有分页技术之前使用的。当时是用于可执行文件。
   在一般UNIX文件系统中，文件的各数据块很可能是随机存放的。为了加速程序的载入，会在第一次执行后，把程序的正文部分存放到交换区，文件在交换区是连续的，这就是称为粘住位的原因，
   也叫保存正文位(S_ISVTX)。
   现在由于配置有虚拟存储系统以及快速文件系统，所以不再需要这种技术。
   
   现今的系统扩展了粘住位的使用范围, 针对目录。如果对一个目录设置了粘住位，则只有对该目录有写权限的用户在满足下列条件之一的情况下，才能删除或更名该目录下的文件：
   1. 拥有该文件
   2. 拥有该目录
   3. 是超级用户
   可以共享一个目录，每个人都能修改自己的文件，但只能看别人的文件。
** chown、fchown和lchown函数
   
   #include <unistd.h>
   int chown(const char *pathname, uid_t owner, gid_t group);
   int fchown(int filedes, uid_t owner, gid_t group);
   int lchown(const char *pathname, uid_t owner, gid_t group);

   在符号链接的情况下，lchown更改符号链接本身的所有者，而不是该符号链接所指向的文件。
   
   如若两个参数owner或group中的任意一个是-1, 则对应的ID不变。
   基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者。这样做的原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。
   系统V则允许任一用户更改他们所拥有的文件的所有者。
   
   若_POSIX_CHOWN_RESTRICTED对指定的文件起作用，则
   1. 只有超级用户进程能更改该文件的用户ID。
   2. 若满足下列条件，一个非超级用户进程就可以更改该文件的组ID:
      1. 进程拥有此文件(其有效用户ID等于该文件的用户ID)。
      2. 参数owner等于-1或文件的用户ID,并且参数group等于进程的有效组ID或进程的附加组ID之一。

   如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组ID位都会被清除。
** 文件长度
   对于目录，文件长度通常是一个数(例如16或512)的倍数。
   对于符号链接，文件长度是文件名中的实际字节数。

*** 文件中的空洞
    ls 看的是文件长度，du看的是文件所使用的磁盘空间总量。
    正常的I/O操作读取整个文件长度，会把空洞读成0,如果使用实用程序(如cat)复制这种文件，那么所有空洞会被填满，填写为0。从而实际占用磁盘空间。
    
    大文件,du报告的长度比ls的长，因为文件系统使用了若干块以存放指向实际数据块的各个指针。
    
** 文件截短
   #include <unistd.h>
   int truncate(const char *pathname, off_t length);
   int ftruncate(int filedes, off_t length);

   这两个函数将把现有的文件长度截短为length字节。
   如果文件以前的长度>length,则length以后的数据不能再访问，
   如果以前的长度短于length,则其效果与系统有关。遵循XSI的系统会增加文件长度，产生空洞。

** 文件系统
   文件系统分类的多种实现：
   1. UFS, UNIX file system, 传统的基于BSD的UNIX文件系统。
   2. PCFS, 读、写DOS格式化软盘的文件系统。
   3. HSFS, 读CD的文件系统。
      
   下面说的是UFS。
   1个磁盘分成一个或多个分区,每个分区可以包含一个文件系统。
   文件系统由自举块、超级块和若干个柱面组 组成。
   每个柱面由 超级块副本、配置信息、i节点图、块位图、i节点和数据块组成。

   i节点是固定长度的记录项，它包含有关文件的大部分信息:
   文件类型、文件访问权限位、文件长度和指向该文件所占用的数据块的指针等等。
   
   只有两项数据存放在目录项中：文件名和i节点编号。
   
   每个文件系统各自对它们的i结点进行编号，因此目录项中的i节点编号数指向同一文件系统中的相应i节点，不能使一个目录项指向另一个文件系统的i节点。
   
** link、unlink、remove和rename函数

   #include <unistd.h>
   int link(const char *existingpath, const char *newpath);

   创建新目录项newpath, 它引用现有的文件existingpath。
   创建新目录项以及增加链接计数应当是个原子操作。
   很多文件系统不允许对于目录的硬链接(可能形成循环)
   
   删除目录项，可以调用unlink函数。
   
   #include <unistd.h>
   int unlink(const char *pathname);

   只有当链接计数达到0时，该文件的内容才可以被删除。另一个条件也会阻止删除文件的内容--只要有进程打开了该文件，其内容也不能删除。
   关闭一个文件时，内核首先检查打开该文件的进程数。如果该数达到0，然后内核检查其链接数，如果这个数也是0，那么就删除该文件的内容。
  
   上面的特性经常用来确保即使是在该程序崩溃时，它所创建的临时文件也不会遗留下来。
   进程用open或creat创建一个文件，然后立即调用unlink。
   

  remove函数解除对一个文件或目录的链接。对于文件，remove = unlink, 对于目录， remove = rmdir 
  #include <stdio.h>
  int remove(const char *pathname);
  
  文件或目录用rename函数更名。
  #include <stdio.h>
  int rename(const char *oldname, const char *newname);
  
  1. 如果oldname指的是一个文件而不是目录，那么为该文件/符号链接更名。
  2. 如若oldname指的是一个目录，则为该目录更名。
  3. 如若oldname或newname引用符号链接，则处理的是符号链接本身，而不是它所引用的文件。
  4. 作为一个特例，如果oldname=newname,函数直接返回。
  如若newname已存在，则要求进程对其有写权限。另外，调用进程需要对包含oldname以及包含newname的目录具有写和执行权限。
  
** 符号链接
   符号链接是指向一个文件的间接指针，它与硬链接不同，硬链接直接指向文件的i结点。引入符号链接的原因是为了避免硬链接的一些限制：
   1. 硬链接通常要求链接和文件位于同一文件系统
   2. 只有超级用户才能创建指向目录的硬链接
      
      各个函数对符号链接的处理
      | 函数     | 不跟随符号链接 | 跟随符号链接 |
      |----------+----------------+--------------|
      | access   |                | *            |
      | chdir    |                | *            |
      | chmod    |                | *            |
      | chown    |                | *            |
      | creat    |                | *            |
      | lchown   | *              |              |
      | link     |                | *            |
      | lstat    | *              |              |
      | open     |                | *            |
      | opendir  |                | *            |
      | pathconf |                | *            |
      | readlink | *              |              |
      | remove   | *              |              |
      | rename   | *              |              |
      | stat     |                | *            |
      | truncate |                | *            |
      | unlink   | *              |              |
      |----------+----------------+--------------|
      
      有个特例，同时用O_CREATE和O_EXCL两者调用open函数。在某些情况下，若路径名引用符号链接，open将出错返回，并将errno设置为EEXIST。这种处理方式的意图是堵塞一个安全性漏洞，
      使具有特权的进程不会被诱骗对不适当的文件进行写操作。
   
** symlink和readlink函数
   symlink创建符号链接
   
   #include <unistd.h>
   int symlink(const char *actualpath, const chat *sympath);
   
   因为open函数会跟随符号链接，所以需要一种方法打开链接本身，并读该链接中的名字。readlink提供此功能。

   #include <unistd.h>
   ssize_t readlink(const char * restrict pathname, char *restrict buf, size_t bufsize);
   此函数组成了open、read、close。成功返回读入buf的字节数。。 
   **需要注意的是buf不以null字符终止**。

** 文件的时间
   与每个文件相关的三个时间值
   | 字段     | 说明                    | 例子         | ls选项 |
   |----------+-------------------------+--------------+--------|
   | st_atime | 文件数据的最后访问时间  | read         | -u     |
   | st_mtime | 文件数据的最后修改时间  | write        | 默认   |
   | st_ctime | i节点状态的最后修改时间 | chmod、chown | -c     |
   |----------+-------------------------+--------------+--------|

   注意，系统并不保存对一个i节点的最后一次访问时间，所以access和stat函数并不更改这三个时间中的任一个。
** utime函数
   一个文件的访问和修改时间可用utime函数更改。
   
   #include <utime.h>
   int utime(const char *pathname, const struct utimbuf *times);

   数据结构如下:
   struct utimbuf {
       time_t actime;/* access time */
       time_t modtime;/* modification time */
   }
   
   此函数的操作以及执行它所要求的特权取决于times参数是否是NULL。
   1. 如果times是一个空指针，则访问时间和修改时间两者都设置为当前时间。为了执行此操作必须满足下列两条件之一：进程的有效用户ID必须等于该文件的所有者ID；或者进程对该文件有写权限。
   2. 如果times是非空指针，则访问时间和修改时间被设置为times所指向结构中的值。此时，进程的有效用户ID必须等于该文件的所有者ID,或者进程必须是一个超级用户进程。
** mkdir和rmdir函数

   #include  <sys/stat.h>
   int mkdir(const char *pathname, mode_t mode);
   
   此函数创建一个新的空目录。其中，.和..目录项是自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。
   
   对于目录通常至少要设置1个执行权限位，以允许访问该目录中的文件名.
   
   用rmdir函数可以删除一个空目录。空目录是指只包含.和..这两项的目录。
   
   #include <unistd.h>
   int rmdir(const char *pathname);
   
  如果调用此函数使目录的链接计数成为0,并且也没有其他进程打开此目录，则释放由此目录占用的空间。
  如果在链接计数达到0时，有一个或几个进程打开了此目录，则在此函数返回前删除最后一个链接及.和..项。
  另外，在此目录中不能再创建新文件。但是在最后一个进程关闭它之前并不释放此目录。
** 读目录
   为了防止文件系统产生混乱，只有内核才能写目录。一个目录的写和执行权限位，决定了在该目录下能否创建新文件和删除文件，它们并不表示能否写目录本身。
   
   目录的实际格式依赖UNIX系统，特别是其文件系统的具体设计和实现。
   很多实现阻止应用程序使用read函数读取目录的内容，从而进一步将应用程序与目录格式中与实现相关的细节隔离开。
   
   #include <dirent.h>
   DIR *opendir(const char *pathname);
   struct dirent *readdir(DIR *dp);

   void rewinddir(DIR *dp);
   int closedir(DIR *dp);
   
   long telldir(DIR *dp);
   
   void seekdir(DIR *dp, long loc);
   
   最基础的定义:
   struct dirent {
       ino_t d_ino;
       char d_name[NAME_MAX + 1];
   }
 
** chdir、fchdir和getcwd函数
   每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当前工作目录是进程的一个属性，起始目录则是登录名的一个属性。

   进程通过chdir或fchdir函数可以更改当前工作目录。
   #include <unistd.h>
   int chdir(const char *pathname);
   int lchdir(int filedes);
   
   内核为每个进程只保存指向该目录v节点的指针等目录本身的信息，并不保存该目录的完整路径名。
   通过getcwd可以取得完整路径名。
   #include <unistd.h>
   char *getcwd(char *buf, size_t size);
   
** 设备特殊文件
   st_dev 与  st_rdev容易引起混淆。
   1. 每个文件系统所在的存储设备都由其主、次设备号表示。主设备号标识设备驱动程序，有时编码为与其通信的外设板；次设备号标识特定的子设备。次设备号标识分区?
   2. 可以用宏major和minor来访问主、次设备号。
   3. 系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点。
   4. 只有字符特殊文件和块特殊文件才有st_rdev值，此值包含实际设备的设备号。
      
* 第五章 标准I/O库
** 引言
   标准I/O库处理很多细节，例如缓冲区分配，以优化长度执行I/O等。
** 流和FILE对象
   不带缓冲的I/O是针对文件描述符的。标准I/O库，是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。
   
   流的定向决定了所读、写的字符是单字节还是多字节的。
   当一个流最初创建时，它并没有定向。
   如若在未定向的流上使用一个多字节I/O函数(见<wchar.h>)，则该流的定向设置为宽定向。
   如若在未定向的流上使用一个单字节I/O函数，则该流的定向设置为字节定向。
   
   只有两个函数可以改变流的定向。freopen清除流的定向, fwide函数设置流的定向(前提是流未定向)
   
   #include <stdio.h>
   #include <wchar.h>
   int fwide(FIFL *fp, int mode);

   fwide无出错返回，解决办法是：在调用fwide前先清除errno, 从fwide返回时检查errno的值。
** 标准输入、准备输出和标准出错
   标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。

   标准I/O提供了三种类型的缓冲：
   1. 全缓冲。 在填满标准I/O缓冲区后才进行实际I/O操作。一般用于磁盘文件。
      flush有两个意思。
      1. 在标准I/O库方面，flush(冲洗)意味着将缓冲区中的内容写到磁盘上。
      2. 在终端驱动程序方面，flush（刷清)表示丢弃已存储在缓冲区中的数据。
   2. 行缓冲。 当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。一般用于终端。
      行缓冲的两个限制：
      1. 缓冲区满时，也会进行I/O操作。
      2. 任何时候只要通过标准I/O库要求从(a)一个不带缓冲的流，或者(b)一个行缓冲的(它要求从内核中得到数据)流得到输入数据，那么就会造成冲洗所有行缓冲输出流。
   3. 不带缓冲。 标准I/O库不对字符进行缓冲存储。一般用于标准错误stderr。
      
   ISO C要求下列缓冲特征：
   1. 当且仅当标准输入和标准输出并不涉及交互式设备时，它们才是全缓冲的。
   2. 标准出错决不会是全缓冲的。
   
   很多系统默认使用下列类型的缓冲：
   1. 标准出错是不带缓冲的。
   2. 如若是涉及终端设备的其他流，则它们是行缓冲的；否则是全缓冲的。
      
   以下函数用来更改缓冲类型：
   #include <stdio.h>
   void setbuf(FILE *restrict fp, char *restrict buf);
   int setvbuf(FILE *restrict fp , char *restrict buf, int mode, size_t size);

   setbuf用来打开/关闭缓冲机制。
   为了带缓冲进行I/O, 参数buf必须指向一个长度为BUFSIZE的缓冲区。通常在此之后就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓冲。
   关闭缓冲，把buf设置为NULL。

   使用setvbuf， 我们可以精确指定所需要的缓冲类型。mode参数：
   1. _IOFBF  全缓冲
   2. _IOLBF 行缓冲
   3. _IONBF 不带缓冲

   注意：如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流。
         另外， 有些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可以存放在缓冲区的实际数据字节数少于size。
         一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。在这种情况下关闭此流时，标准I/O库将自动释放缓冲区。
         
         
   #include <stdio.h>
   inf fflush(FILE *fp);

   用于强制冲洗一个流。若fp为NULL, 则此函数将导致所有输出流被冲洗。
** 打开流
   
   #include <stdio.h>
   FILE *fopen(const char *restrict pathname, const char *restrict type);
   FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
   FILE *fdopen(int filedes, const char *type);

   1. fopen打开一个指定的文件
   2. freopen,在指定的流上打开文件。如果已经打开，则先关闭。若流已定向，则清除该定向。主要用于预定义的流：标准输入、标准输出和标准出错。
   3. fdopen获取一个现有的文件描述符，并使一个标准的I/O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符。
      

   当以读和写类型打开一文件时(type中+符号),具有下列限制：(同一块缓冲只有输入/输出数据，不能同时存在)
   1. 如果中间没有fflush、fseek、fsetpos或rewind, 则在输出的后面不能直接跟随输入。
   2. 如果中间没有fseek、fsetpos或rewind, 或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出。

      
   调用fclose来关闭一个打开的流
   
   #include <stdio.h>
   int fclose(FILE *fp);

   在该文件被关闭之前，冲洗缓冲区中的输出数据。丢弃缓冲区中的任何输入数据。

   当一个进程正常终止时，则所有带未写缓冲数据的标准I/O流都会被冲洗，所有打开的标准I/O流都会被关闭。
** 读和写流
   一旦打开了一个流，则可在三种不同类型的非格式化I/O中进行选择：
   1. 每次一个字符的I/O。
   2. 每次一行的I/O。
   3. 直接I/O,也叫二进制I/O，每次读写一个对象。(fread和fwrite支持)。

*** 输入函数
    每次一个字符的I/O
    #include <stdio.h>
    int getc(FILE *fp);
    int fgetc(FILE *fp);
    int getchar(void);

    getc可以实现为宏，则fgetc只能是函数。

    注意：不管是出错还是到达文件尾端，这三个函数都返回同样的值。为了区分这两种不同的情况，必须调用ferror或feof。
    #include <stdio.h>
    int ferror(FILE *fp);
    int feof(FILE *fp);
    void clearerr(FILE *fp);

    在大多数实现中，为每个流在FILE对象中维持了两个标志：
    1. 出错标志。
    2. 文件结束标志。
    调用clearerr则清除这两个标志。

    从流中读取数据以后，可以调用ungetc将字符再压送回流中。
    #include <stdio.h>
    int ungetc(int c, FILE *fp);

    虽然ISO C允许实现支持任何次数的回送，但是它要求实现提供一次只送回一个字符。我们不能期望一次能送回多个字符。??? **为什么这样设定**
 
   回送的字符不必一定是上一次读到的字符。不能回送EOF。但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再次读则返回EOF。之所以这样做的原因是一次成功的ungetc调用
   会清除该流的文件结束标志。 
    
*** 输出函数
    对应于上面的三个输入函数。有三个输出函数
    #include <stdio.h>
    int putc(int c, FILE *fp);
    int fputc(int c, FILE *fp);
    int putchar(int c);
   
** 每次一行I/O
*** 输入函数
    #include <stdio.h>
    char *fgets(char *restrict buf, int n, FILE *restrict fp);
    char *gets(char *buf);
    
    缓冲区总是以null字符结尾。
    
    gets并不推荐使用，因为不能指定缓冲区的长度，可能造成缓冲区溢出(如若该行长于缓冲区长度），写到缓冲区之后的存储空间中，从而产生不可预料的后果。
    
    **处处是坑，难道需要更高级的语言，来避免这些坑。但专家级的程序员一定需要知道这些坑，并能直面这些坑**
*** 输出函数
    #include <stdio.h>
    int fputs(const char *restrict str, FILE *restrict fp);
    int puts(const char *str);
    
    如果总是使用fgets和fputs, 那么就会熟知在每行终止处我们必须自己处理换行符。
    
** 二进制I/O
   下列两个函数执行二进制I/O操作
   #include <stdio.h>
   size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
   size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
   
   两种常用的用法：
   1. 读或写一个二进制数组。
   2. 读或写一个结构。
      
   
   使用二进制I/O的基本问题是， 它只能用于读在同一系统上已写的数据。
   但是我们常遇到在一个系统上写的数据，要在另一个系统上进行处理。这种情况下，这两个函数可能不能正常工作。
   1. 在一个结构中，同一成员的偏移量可能因编译器和系统而异。即使在同一个系统上，一个结构的二进制存放方式也可能因编译器选项的不同而不同。
   2. 用来存储多字节整数和浮点值的二进制格式在不同的机器体系结构间也可能不同。

     
   在不同系统之间交换二进制数据的实际解决方法是使用较高级的协议。
** 定位流
   有三种方法定位标准I/O流。
   1. ftell和fseek函数。
   2. ftello和fseeko函数。
   3. fgetpos和fsetpos函数。

     
   需要移植到非UNIX系统上运行的应用程序应当使用fgetpos和fsetpos。

   #include <stdio.h>
   long ftell(FILE *fp);
   int fseek(FILE *fp, long offset, int whence);
   void rewind(FILE *fp);
   

   对于一个二进制文件，其文件位置指示器是从文件起始位置开始度量，并以字节为度量单位。
   对于文本文件，它们的文件当前位置可能不以简单的字节偏移量来度量。
   为了定位一个文本文件，whence一定要是SEEK_SET, 而且offset只能有两种值：0，或是对该文件调用ftell所返回的值。

   
   ftello和ftell只是返回值类型不一样。
   #include <stdio.h>
   off_t ftello(FILE *fp);
   int fseeko(FILE *fp, off_t offset, int whence);
   
   #include <stdio.h>
   int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
   int fsetpos(FILE *fp, const fpos_t *pos);
** 格式化I/O
*** 格式化输出
    4个函数
    
    #include <stdio.h>
    int printf(const char *restrict format, ...);
    int fprintf(FILE *restrict fp, const char *restrict format, ...);
    
    int sprintf(char *restrict buf, const char *restrict format, ...);
    int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
    
    sprintf在该数组的尾端自动加一个null字节，但该字节不包括在返回值中。
    
    注意，sprintf函数可能会造成由buf指向的缓冲区的溢出。调用者有责任确保该缓冲区足够大。为了解决这个问题，引入的snprintf函数。
    
    下列4种printf族的变体类似于上面的4种，但是可变参数表(...)代换成了arg。
    
    #include <stdarg.h>
    #include <stdio.h>
    
    int vprintf(const char *restrict format, va_list arg);
    int vfprintf(FILE *restrict fp, const char *restrict format, va_list arg);
    
    int vsprintf(char *restrict buf, const char *restrict format, va_list arg);
    int vsnprintf(char *restrict buf, size_t n, const char *restrict format, va_list arg);
    
*** 格式化输入
    3个scanf函数
    
    #include <stdio.h>
    int scanf(const char *restrict format, ...);
    int fscanf(FILE *restrict fp, const char *restrict format, ...);
    int sscanf(const char *restrict buf, const char *restrict format, ...);
    
    同printf族一样，scanf族也支持函数使用由<stdarg.h>说明的可变参数表。

    #include <stdarg.h>
    #include <stdio.h>
    int vscanf(const char *restrict format, va_list arg);
    int vfscanf(FILE *restrict fp, const char *restrict format, va_list arg);
    int vsscanf(const char *restrict buf, const char *restrict format, va_list arg);
** 实现细节
   可以通过流得到文件描述符

   #include <stdio.h>
   int fileno(FILE *fp);
** 临时文件
   ISO C标准I/O库提供了两个函数以帮助创建临时文件。
   
   #include <stdio.h>
   char *tmpnam(char *ptr);
   FILE *tmpfile(void);
   
   若ptr是NULL, 则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。
   下一次调用tmpnam时，会重写该静态区。

   若ptr不是NULL，则认为它指向长度至少是L_tmpnam个字符的数组。
   
   tempfile创建一个临时二进制文件(wb+),在关闭该文件或程序结束时将自动删除这种文件。
   
   XSI的扩展部分提供了另两个函数。
   
   #include <stdio.h>
   char *tempname(const char *directory, const char *prefix);
   
   允许调用者为所产生的路径名指定目录和前缀。对于目录有4种不同的选择，按下列顺序判断其条件是否为真，并且使用第一个为真的作为目标：
   1. 如果定义了环境变量TMPDIR, 则用其作为目录。
   2. 如果参数directory非NULL, 则用其作为目录。
   3. 将<stdio.h>中的字符串P_tmpdir用作目录。
   4. 将本地目录(通常是/tmp)用作目录。

   如果prefix非NULL, 则它应该是最多包含5个字符的字符串。
   
   XSI定义的第二个函数是mkstemp。类似于tmpfile, 返回的是临时文件的打开文件描述符。
   #include <stdlib.h>
   int mkstemp(char *template);
   
   与tmpfile不同的是，mkstemp创建的临时文件不会自动被删除。

   使用tmpnam和tempnam的一个不足之处是：在返回唯一路径名和应用程序用该路径名创建文件之间有一个时间窗口。
   在该时间窗口期间，另一个进程可能创建一个同名文件。
   tmpfile和mkstemp函数则不会产生此种问题，可以使用它们代替tmpnam和tempnam。
   
** 标准I/O的替代软件
   标准I/O库的一个不足之处是效率不高。有两次复制：从内核复制到标准I/O缓冲，从缓冲复制到用户程序的行缓冲。
   快速I/O库(fio)避免了这一点，其方法是使读一行的函数返回指向该行的指针，而不是将该行复制到另一个缓冲区中。
   sfio, 扩展了I/O流，不仅可以代表文件，也可以代表存储区；可以编写处理模块，并以栈方式将其压入I/O流；较好的异常操作。
   ASI, 使用了映射文件--mmap函数。ASI使用指针力图减少数据复制量。
   
   不可移植，但性能更好的 uClibc C库和newlibc C库，适用于嵌入式系统。
* 第六章 系统数据文件和信息
** 口令文件
   <pwd.h> paswd结构
   /etc/passwd文件中的字段
   | 说明         | struct passwd成员 |
   |--------------+-------------------|
   | 用户名       | char *pw_name     |
   | 加密口令     | char *pw_passwd   |
   | 数值用户ID   | uid_t pw_uid      |
   | 数值组ID     | uid_t pw_gid      |
   | 注释字段     | char *pw_gecos    |
   | 初始工作目录 | char *pw_dir      |
   | 初始Shell    | char *pw_shell    |
   | 用户访问类   | char *pw_class    |
   | 下次更改口令文件 | time_t pw_change  |
   | 账户到期时间     | time_t pw_expire  |
   
   为了阻止一个特定用户登录系统，有几种办法：
   1. 初始Shell 设置为 /dev/null
   2. 初始shell 设置为 /bin/false
   3. 初始shell 设置为 /bin/true
   4. 初始shell 设置为 nologin,需要系统支持。
   
   有些系统提供vipw命令来修改/etc/passwd文件。
   提供finger命令的某些系统支持注释字段中的附加信息。
   
   #include <pwd.h>
   struct passwd *getpwuid(uid_t uid);
   struct passwd *getpwnam(const char *name);
   
   下列三个函数可用于读取整个口令文件。
   #include <pwd.h>
   struct passwd *getpwent(void);//打开文件并读取.
   void setpwent(void);//回到文件开头
   void endpwent(void);//关闭文件
   
** 阴影文件
   /etc/shadow文件中的字段
   | 说明                       | struct spwd成员 |
   |----------------------------+-----------------|
   | 用户登录名                 | char *sp_namp   |
   | 加密口令                   | char *sp_pwdp   |
   | 上次更改口令以来经过的时间 | int sp_lstchg   |
   | 经过多少天后允许更改       | int sp_min      |
   | 要求更改尚余天数           | int sp_max      |
   | 到期警告天数               | int sp_warn     |
   | 账户不活动之前尚余天数     | int sp_inact    |
   | 账户到期天数               | int sp_expire   |
   | 保留                       | unsigned int sp_flag |
   
   一组类似的函数访问阴影口令文件。
   
   #include <shadow.h>
   struct spwd *getspnam(const char *name);
   struct spwd *getspent(void);
   void setspent(void);
   void endspent(void);
   
   mac没有阴影口令文件，类似的参考/etc/master.passwd
** 组文件
   /etc/group文件中的字段
   | 说明                     | struct group成员 |
   |--------------------------+------------------|
   | 组名                     | char *gr_name    |
   | 加密口令                 | char *gr_passwd  |
   | 数值组ID                 | int gr_gid       |
   | 指向各用户名的指针的数组 | char **gr_mem   |
   
   查看数组名或数值组ID
   #include <grp.h>
   struct group *getgrgid(gid_t gid);
   struct group *getgrnam(const char *name);

   
   搜索整个组文件函数
   #include <grp.h>
   struct group *getgrent(void);
   void setgrent(void);
   void endgrent(void);
   
** 附加组ID
   口令newgrp可以更改组id。
   
   为了获取和设置附加组ID,提供了下列三个函数：
   #include <unistd.h>
   int getgroups(int gidsetsize, gid_t grouplist[]);
   
   #include <grp.h> /* on linux */
   #include <unistd.h> /* on freebsd, mac os x , amd solaris */
   int setgroups(int ngroups, const gid_t grouplist[]);

   #include <grp.h> /* on linux and solaris */
   #include <unistd.h> /* on freebsd and mac os x */
   int initgroups(const char *username, gid_t basegid);
** 实现的区别
** 其他数据文件
   存取系统数据文件的类似例程 
   | 说明 | 头文件     | 数据文件       | 结构     | 附加的关键字查找函数             |
   |------+------------+----------------+----------+----------------------------------|
   | 口令 | <pwd.h>    | /etc/passwd    | passwd   | getpwnam、getpwuid               |
   | 组   | <grp.h>    | /etc/group     | group    | getgrname、getgrgid              |
   | 阴影 | <shadow.h> | /etc/shadow    | spwd     | getspnam                         |
   | 主机 | <netdb.h>  | /etc/hosts     | hostent  | gethostbyname、gethostbyaddr     |
   | 网络 | <netdb.h>  | /etc/networks  | netent   | getnetbyname、getnetbyaddr       |
   | 协议 | <netdb.h>  | /etc/protocols | protoent | getprotobyname、getprotobynumber |
   | 服务 | <netdb.h>  | /etc/services  | servent  | getservbyname、getservbyport      |
  
** 登录账户记录
   大多数UNIX系统都提供下列两个数据文件：
   1. utmp文件，记录当前登录进系统的各个用户。
   2. wtmp文件，跟踪各个登录和注销事件。

   struct utmp {
       char ut_line[8]; /* tty line : "ttyh0", "ttyd0" ... */
       char ut_name[8];/ login name */
       long ut_time; /* seconds since Epoch */

   }
   
   登录时，login程序填写此类结构，然后写入utmp文件，同时添加至wtmp文件。
   注销时，init进程将utmp相应的记录擦除，并将一个新记录添加到wtmp文件。
   
   who程序读取utmp文件。 last程序读取wtmp文件。
** 系统标识
   uname函数。
   #include <sys/utsname.h>
   int uname(struct utsname *name);
   
   struct utsname {
       char sysname[];/* name of operating system */
       char nodename[]; /* name of this node */
       char release[]; /*current release of operating system */
       char version[]; /* current version of this release*/
       char machine[]; /* name of hardware type*/
   }
   
   gethostname获取TCP/IP网络上主机的名字。
   #include <unistd.h>
   int gethostname(char *name, int namelen);
   主机名的最大名字长度 HOST_NAME_MAX。

   hostname 用于获取和设置主机名。
** 时间和日期例程
   日历时间包括日期和时间。
   UNIX在这方面与其他操作系统的区别是：
   1. 以国际标准时间而非本地时间计时；
   2. 可自动进行转换，例如变换到夏时制
   3. 将时间和日期作为一个量值保存。
      

   time函数返回当时时间和日期
   #include <time.h>
   time_t time(time_t *calptr);
   
   在BSD派生的系统中，调用settimeofday,用于对内核中的当前时间设置初始值。
   #include <sys/time.h>
   int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
   tzp的唯一合法值是NULL,其他值则将产生不确定的结果。

   struct timeval{
       time_t tv_sec;
       long tv_usec;/*微秒*/
   }
   
   localtime和gmtime把time_t转成tm结构，tm结构包括年、月、日、时、分、秒、周日等。
   struct tm{ /* a broken-down time */
       int tm_sec; /* seconds after the minute:[0-60]*/
       int tm_min; /* minutes after the hour: [0-59] */
       int tm_hour:/* hours after midnight: [0-23] */
       int tm_day: /* day of the month */
       int tm_mon; /* months since January: [0-11] */
       int tm_year; /* years sinsce 1900 */
       int tm_wday; /* days since Sunday:[0-6] */
       int tm_yday; /* days since January 1: [0-365]*/
       int tm_isdst; /* daylight saving time flag: <0, 0, >0 */
   }
   
   秒可以越过59的理由是可以表示润秒。
   **闰秒（或称跳秒）是对UTC(协调世界时)作出加一秒或减一秒的调整，用来协调不均匀的地球自转时间与原子时间之间的差值不超过0.9秒。**

   #include <time.h>
   struct tm *gmtime(const time_t *calptr);/*转成国际标准时*/
   struct tm *localtime(const time_t *calptr);/*转成本地时间,受TZ影响*/
   
   #include <time.h>
   time_t mktime(struct tm *tmptr);/*转成日历时间, tmptr是本地时间,受TZ影响*/
   
   #include <time.h>
   char *asctime(const struct tm *tmptr);/*把tm结构的时间转成字符串时间*/
   char *ctime(const time_t *calptr);/*把日历时间转成字符串时间,受TZ影响*/
   
   #include <time.h>
   size_t strftime(char *restrict buf, size_t maxsize, const char *restrict format, const struct tm *restrict tmptr);/*格式化时间,受TZ影响*/
   
   第一周有不同的定义：
   * %U, 包含该年第一个星期日的周为第一周。
   * %W，包含该年第一个星期一的周为第一周。
   * %V, 若某周包含了1月1日，而且至少包含了其后的另外3天，那么该周是一年的中第一周，否则该周被认为是上一年的最后一周。(周一被视为每周的第一天)
     
* 第七章 进程环境
** main函数
   int main(int argc, char *argv[]);

   当内核执行C程序时(使用一个exec函数), 在调用main函数前先调用一个特殊的启动例程。
   可执行程序文件将此启动例程指定为程序的起始地址--这是由连接编译器设置的，而连接编译器则由C编译器调用。
   启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。
   **启动例程是啥?**
   需要用到编译原理
   gcc main.o -o main 其实是类似调用的
   ld /usr/lib/crt1.o /usr/lib/crti.o main.o -o main -lc -dynamic-linker /lib/ld-linux.so.2
   启用例程便是指的/usr/lib/ctr1.o中的start函数。
** 进程终止
   5种正常终止
   1. 从main返回。
   2. 调用exit
   3. 调用_exit或_Exit。
   4. 最后一个线程从其启动例程返回。
   5. 最后一个线程调用pthread_exit

   3种异常终止
   1. 调用abort
   2. 接到一个信号并终止
   3. 最后一个线程对取消请求做出响应
      
   启动例程调用：
   exit(main(argc,argv));

*** exit函数
    有3个函数用于正常终止程序：_exit和_Exit立即进入内核,exit则先执行一些清理处理(包括调用执行各终止处理程序，关闭所有标准I/O流等），然后进入内核。
    #include <stdlib.h>
    void exit(int status);
    void _Exit(int status);
    
    #include <unistd.h>
    void _exit(int status);
    
    以下三种情况，进程的终止状态是未定义的：
    1. 调用这些函数时(以上3个），不带终止状态。
    2. main执行了一个无返回值的return语句。
    3. main没有声明返回类型为整形。
    
       

    
*** atexit函数
    上文提到exit会执行一些清理操作，这些清理操作是由atexit登录的，按ISO C的规定，一个进程可以登记多达32个函数。
    这些程序称为终止处理程序。
    #include <stdlib.c>
    int atexit(void (*func)(void));
    
    exit调用这些函数的顺序与登记顺序相反。同一函数如若登记多次，也会调用多次。
    
    根据ISO C和POSIX.1, exit首先调用各终止处理程序，然后按需多次调用fclose，关闭所有打开流。
    POSIX.1扩展了ISO C标准，它指定如若程序调用exec函数族中的任一函数，则将清除所有已安装的终止处理程序,这里是指的清除子进程的，父进程不受影响。

    内核使程序执行的唯一入口是调用一个exec函数。
    进程自愿终止的唯一方法是显示或隐式地调用_exit或_Exit。
    
** 命令行参数
   调用exec的进程可将命令行参数传递给该新程序，这是UNIX SHELL的一部分常规操作。
** 环境表
   每个程序都会接收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以null结束的C字符串的地址，内容为key=value的形式。
   全局变量environ包含了该指针的地址：
   extern char **environ;
   通常使用getenv和putenv函数来访问特定的环境变量，而不是用environ变量。但是，如果要查看整个环境，则必须使用environ指针。
** C程序的存储空间布局
   从历史上讲，C程序一直由下面几部分组成：
   1. 正文段。这是由CPU执行的机器指令部分。通常，正文段是可共享的。
   2. 初始化数据段。通常称此段为数据段，它包含了程序中需明确地赋初值的变量。
   3. 非初始化数据段。通常称此段为bss段。在程序开始执行之前，内核将此段中的数据初始化为0或空指针。
   4. 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。
      每次调用函数时，其返回地址以及调用者的环境信息（例如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。
      通过这种方式使用栈，可以递归调用C函数。
      递归函数每次调用自身时，就使用一个新的栈帧，因此一个函数调用实例中的变量集不会影响到另一个函数调用实例中的变量。
      **栈帧的结构是怎么样的?**
      从逻辑上讲，栈帧就是一个函数执行时环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。
      实现上有硬件方式和软件方式。

   5. 堆。通常在堆中进行动态存储分配。
      
   在linux上典型的安装方式是: 从高地址到低地址依次是 命令行参数和环境变量->栈(栈从高地址向低地址方向增长)->虚地址空间->堆->未初始化数据->初始化数据->正文。
   
   size命令可以报告正文段、数据段和bss段的长度。
** 共享库
   共享库使得可执行文件中不再需要包含公用的库例程，而只需在所有进程都可引用的存储区中维护这种库例程的一个副本。
   程序第一次执行或第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。
   这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。
   共享库的另一个优点是可以用库函数的新版本代替老版本，而无需对使用该库的程序重新连接编辑。
** 存储器分配
   3个动态分配函数：
   1. malloc. 分配指定字节数的存储区。此存储区中的初始值不确定。
   2. calloc. 为指定 多个 具指定长度的对象 分配存储空间。该空间中的每一位都初始化为0.
   3. realloc. 更改以前分配的长度(增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。
      
    
   #include <stdlib.h>
   void *malloc(size_t size);
   void *calloc(size_t nobj, size_t size);
   void *realloc(void *ptr, size_t newsize);

   void free(void *ptr);
   
   这3个分配函数所返回的值一定是适当对齐的，使其可用于任何数据对象。
   函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池。
   因为realloc分配的存储区可能会移动位置，所以不应当使任何指针指到该区中,只能保留首地址，并且需要及时更新.

   这些分配例程通常用sbrk系统调用实现。该系统调用扩大（或缩小）进程的堆。
   虽然sbrk可以扩大或缩小进程的存储空间，但是大多数malloc和free的实现都不减小进程的存储空间。释放的空间可供以后再分配，但通常将它们保持在malloc池中而不返回给内核。
   
   应当注意的是，大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息--分配块的长度、指向下一个分配块的指针等等。
   产生致命性的错误有：
   1. 在动态分配的缓冲区前或后进行写操作。
   2. 释放一个已经释放的块。(两次释放之间，可能内存已经被用了)
   3. 调用free时所用的指针不是三个alloc函数的返回值。
      

   若一个进程调用了malloc函数，但却忘记调用free函数，那么该进程占用的存储器就会连续增加，这被称为泄露。
   为了防止错误使用存储分配器函数。提供了以下替换库：
   1. libmalloc
   2. vmalloc
   3. 快速适配
   4. alloca函数

** 环境变量
   #include <stdlib.h>
   char *getenv(const char *name);
   此函数返回一个指针，它指向name=value字符串中的value。注意，环境表中，指针数组指向的其实是name=value的字符串。
   Single UNIX Specification定义的环境变量
   | 变量        | 说明                           |
   |-------------+--------------------------------|
   | COLUMNS     | 终端宽度                       |
   | DATEMSK     | getdate(3)模块文件路径名       |
   | HOME        | 起始目录                       |
   | LANG        | 本地名                         |
   | LC_ALL      | 本地名                         |
   | LC_COLLATE  | 本地排序名                     |
   | LC_CTYPE    | 本地字符分类名                 |
   | LC_MESSAGES | 本地消息名                     |
   | LC_MONETARY | 本地货币编辑名                 |
   | LC_NUMERIC  | 本地数字编辑名                 |
   | LC_TIME     | 本地日期/时间格式名            |
   | LINES       | 终端高度                       |
   | LOGNAME     | 登录名                         |
   | MSGVERB     | fmtmsg(3)处理的消息组成部分    |
   | NLSPATH     | 消息类模板序列                 |
   | PATH        | 搜索可执行文件的路径前缀列表   |
   | PWD         | 当前工作目录的绝对路径名       |
   | SHELL       | 用户首选的shell名              |
   | TERM        | 终端类型                       |
   | TMPDIR      | 在其中创建临时文件的目录路径名 |
   | TZ          | 时区信息                       |
   |-------------+--------------------------------|
   
   命令ENV可以查看环境变量。
   我们也能设置环境变量的值。我们能影响的只是当前进程及调用的任何子进程的环境，但不能影响父进程的环境，这通常是一个shell进程。


   #include <stdlib.h>
   int putenv(char *str);
   
   int setenv(const char *name, const char *value, int rewrite);
   int unsetenv(const char *name);
   由于环境表和环境字符串通常存放在进程存储空间的顶部。它既不能向高地址扩展，也不能向低地址扩展。
   在修改或新增时比较麻烦。在空间不够时，需要用malloc在堆申请内存空间，然后把整个环境表copy到堆。但原来的name=value还是在存储空间的顶部。这样就会是两个存储空间的混合使用。
   可见增加环境变量的效率不会高。
** setjmp和longjmp函数
   非局部指的是，这不是由普通C语言goto语句在一个函数内实施的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中。
   #include <setjmp.h>
   int setjmp(jmp_buf env);
   
   void longjmp(jmp_buf env, int val);

   规范的使用方式是将env变量定义为全局变量。
   
   对于一个setjmp,可以有多个longjmp。val用来区分从哪调用的longjmp。
   
   调用longjmp造成main中的setjmp的返回，但是这一次的返回值是longjmp的第二个参数。
*** 自动、寄存器和易失变量
    当longjmp返回到setjmp时(上例是main), 自动变量和寄存器变量的值是否会恢复到以前调用setjmp时的值，或者保持为调用longjmp时的值？
    答案是“看情况”。大多数实现并不回滚这些自动变量和寄存器变量的值，而所有标准则说它们的值是不确定的。

    如果你有一个自动变量，而又不想使其值回滚，则可定义为具有volatile属性。
    声明为全局或静态变量的值在执行longjmp时保持不变。(在数据段,bss?)
    **C语言volatile**
    用于告诉编译器这个变量是容易变化的，不需要优化(如使用寄存器优化)，每次用的时候，直接从原内存中读取。避免寄存器、CPU高级缓存等导致的数据不一致性。
    
    如果要编写一个使用非局部跳转的可移植程序，则必须使用volatile属性。但是从一个系统移植到另一个系统，任何事情都可能改变。
*** 自动变量的潜在问题
    声明自动变量的函数返回后，不能再使用这些自动变量。
** getrlimit和setrlimit函数
   每个进程都有一组资源限制，其中一些可以用getrlimit和setrlimit函数查询和更改。
   #include <sys/resource.h>
   int getrlimit(int resource, struct rlimit *rlptr);
   int setrlimit(int resource, const struct rlimit *rlptr);
   
   进程的资源限制通常是在系统初始化时由进程0建立的，然后由每个后续进程继承。
   struct rlimit{
       rlim_t rlim_cur;/* soft limit ,current limit */
       rlim_t rlim_max;/* hard limit: maximum value for rlim_cur */
   }
   
   在更改资源限制时，须遵循下列三条规则：
   1. 任何一个进程都可将一个软限制值更改为小于或等于其硬限制值。
   2. 任何一个进程都可降低其硬限制值，但它必须>=其软限制值。这种降低对普通用户而言是不可逆的。
   3. 只有超级用户进程可以提高硬限制值。
   
      
   资源限制
   | 限制           | 说明                                                                                  |
   |----------------+---------------------------------------------------------------------------------------|
   | RLIMIT_AS      | 进程可用存储区的最大总长度。这会影响sbrk函数和mmap函数                                |
   | RLIMIT_CORE    | core文件的最大字节数，若其值为0则阻止创建core文件。                                   |
   | RLIMIT_CPU     | CPU时间的最大量值(秒),当超过此软限制时，向该进程发送SIGXCPU信号。                     |
   | RLIMIT_DATA    | 数据段的最大字节长度。是初始化的数据+未初始化数据+堆                                  |
   | RLIMIT_FSIZE   | 可以创建的文件的最大字节长度。当超过此软限制时，则向该进程发送SIGXFSZ信号             |
   | RLIMIT_LOCKS   | 一个进程可持有的文件锁的最大数                                                        |
   | RLIMIT_MEMLOCK | 一个进程使用mlock(2)能够锁定在存储器中的最大字节长度。                                |
   | RLIMIT_NOFILE  | 每个进程能打开的最大文件数。更改此限制将影响到sysconf函数在参数_SC_OPEN_MAX中返回的值 |
   | RLIMIT_RSS     | 最大驻内存集的字节长度。如果物理存储器供不应求，则内核将从进程处取回超过RSS的部分。   |
   | RLIMIT_SBSIZE  | 用户在任一给定时刻可以占用的套接字缓冲区的最大长度(字节)。                            |
   | RLIMIT_STACK   | 栈的最大字节长度。                                                                    |
   | RLIMIT_VMEM    | 这是RLIMIT_AS的同意词                                                                 |

   ulimit命令可以查看和设置。
   **什么是core文件?**
   当程序crash时，操作系统会把程序Down掉时的内存拷贝一分到core文件，供分析使用。
   
* 第八章 进程控制
** 进程标识符
   每个进程都有一个非负整型表示的唯一进程ID。因为是唯一的，常将其用作其他标识符的一部分以保证其唯一性。
   虽然是唯一的，但是进程ID可以重用。
   大多数UNIX系统实现延迟重用算法， 使得赋予新建进程的ID不同于最近终止进程所使用的ID。

   系统专用进程：
   1. 进程0, 调度进程，也叫交换进程,也叫系统进程。是内核的一部分，它并不执行任何磁盘上的程序。
   2. 进程1, init进程，是用户进程，但是由超级用户特权执行，是所有孤儿进程的父进程。在自举过程结束后由内核调用。程序文件是/etc/init, 较新版本是/sbin/init。
      此进程负责在自举内核后启动一个UNIX系统。init通常读与系统有关的初始化文件(/etc/rc*文件或/etc/inittab文件，以及/etc/init.d中的文件),并将系统引导到一个状态，init进程绝不会终止。
   3. 进程2, 页守护进程。负责支持虚拟存储系统的分页操作。
      
      
   #include <unistd.h>
   pid_t getpid(void);
   pid_t getppid(void);

   uid_t getuid(void);
   uid_t geteuid(void);
   gid_t getgid(void);
   gid_t etegid(void);

** fork函数
   创建新进程
   #include <unistd.h>
   pid_t fork(void);

   fork函数被调用一次，但返回两次。对父进程返回子进程ID, 对子进程返回0.
   
   子进程获得父进程数据空间、堆和栈的副本。父子进程并不共享这些存储空间部分，父、子进程共享正文段。
   
   由于在fork之后经常跟随着exec,所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。
   作为替代，使用了写时复制技术。
   这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。
   如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统中的一“页”。

   一般来说，在fork之后是父进程还是子进程执行是不确定的。

   strlen和sizeof的区别：
   1. strlen会计算不包含终止null字节的字符串长度。sizeof会包含null
   2. strlen有一次函数调用。sizeof在编译时确定了缓冲区长度。只是针对char buf[] = "hello",这样的声明。
      
*** 文件共享
    fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。父子进程的每个相同的打开描述符共享一个文件表项。
    这种共享文件的方式使父、子进程对同一个文件使用了一个文件偏移量。


    在fork之后处理文件描述符有两种常见的情况：
    1. 父进程等待子进程完成。不需要特殊处理。因为共享文件表项。
    2. 父、子进程各自执行不同的程序段。在这种情况下，父、子进程各自关闭它们不需要使用的文件描述符，这样就不会干扰对方使用的文件描述符。
       这种方法就是网络服务进程中经常使用的。

       
    除了打开文件之外，父进程的很多其他属性也由子进程继承，包括
    * 实际用户ID、实际组ID、有效用户ID、有效组ID、附加组ID
    * 进程组ID
    * 会话ID
    * 控制终端
    * 设置用户ID标志和设置组ID标志
    * 当前工作目录
    * 根目录
    * 文件模式创建屏蔽字
    * 信号屏蔽和安排
    * 针对任一打开文件描述符的在执行时关闭(close-on-exec)标志。
    * 环境。
    * 连接的共享存储段。
    * 存储映射。
    * 资源限制.

     
    父、子进程之间的区别是：
    * fork的返回值。
    * 进程ID不同
    * 两个进程具有不同的父进程ID
    * 子进程的tms_utime、tms_stime、tms_cutime以及tms_ustime均被设置为0。
    * 父进程设置的文件锁不会被子进程继承。
    * 子进程的未处理的闹钟(alarm)被清除。
    * 子进程的未处理信号集设置为空集。
    
    
    使fork失败的两个主要原因是：
    1. 系统中已经有了太多的进程。
    2. 该实际用户ID的进程总数超过了系统限制。

       
    fork有下面两种用法：
    1. 一个父进程希望复制自己，使父、子进程同时执行不同的代码段。在网络服务进程中常见。
    2. 一个进程要执行一个不同的程序。shell中常见。

       
    某些操作系统会把fork和exec组合成一个，并称其为spawn。
    分开的好处是：
    1. 很多场合需要单独使用fork,其后不跟随exec
    2. 在fork和exec之间可以更改自己的属性，如I/O重定向、用户ID、信号安排等。
** vfork函数
   vfork已被标记为废弃接口，和fork的第2个用法的目的相同，是为了exec一个新程序。
   区别：
   1. vfork创建的子进程，并不将父进程的地址空间完全复制到子进程中，在调用exec或exit之前，是在父进程的地址空间中运行。
   2. vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度执行(如果在调用这两个函数之前子进程依赖父进程的进一步动作，则会导致死锁)。
   
** exit函数
   不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器。
   正常终止的情况，传参给exit、_exit和_Exit 可以把 **退出状态** 传递给父进程。
   异常终止的情况，内核会产生一个指示异常终止原因的 **终止状态** 。之后父进程可以通过调用wait或waitpid函数取得其终止状态。
   
   两种情况：
   1. 父进程比子进程先死，子进程的父进程会自动变更为init进程。
      >在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则将该进程的父进程ID更改为1。
   2. 子进程比父进程先死，内核为每个终止子进程保存了一定量的信息，当父进程调用wait或waitpid时，可以得到这些信息。
      >这些信息至少包括进程ID、该进程的终止状态、以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。

      
   一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息，释放它仍占用的资源）的进程被称为僵死进程。
   ps（1）命令将僵死进程的状态打印为Z。
   


   init进程被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中有很多僵死进程。

** wait和waitpid函数
   当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号(signal child?)。
   这个信号是个异步信号，父进程接收到后可以选择忽略，也可以提供一个信号处理函数来处理。系统的默认处理是忽略。
   调用wait或waitpid可能发生的情况：
   1. 如果其所有子进程都还在运行，则阻塞。
   2. 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。
   3. 如果它没有任何子进程，则立即出错返回。

      
   如果进程由于接收到SIGCHLD信号而调用wait,则可期望wait会立即返回。

   #include <sys/wait.h>
   pid_t wait(int *statloc);
   pid_t waitpid(pid_t pid, int *statloc, int options);
   
   区别如下：
   1. 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞。options = WNOHANG?
   2. waitpid并不等待在其调用之后的第一个终止进程，它有若干个选项，可以控制它所等待的进程。

      
   状态字是由实现定义的。某些位表示退出状态，其他位则指示信号编号(异常返回),有一位指示是否产生了core文件等。
   POSIX.1规定终止状态用定义在<sys/wait.h>中的各个宏来查看。如下表所示

   | 宏                   | 说明                                                                                                                    |
   |----------------------+-------------------------------------------------------------------------------------------------------------------------|
   | WIFEXITED(status)    | 若为正常终止子进程返回的状态，则为真。对于这种情况可执行WEXITSTATUS(status),取子进程传送给exit、_exit、_Exit参数的低8位 |
   | WIFSIGNALED(status)  | 若为异常终止子进程返回的状态，则为直。对于这种情况，可执行WTERMSIG(status),取使子进程终止的信号编号。另外，有些实现定义 |
   |                      | 宏WCOREDUMP(status),若已产生终止进程的core文件，则它返回真。                                                            |
   | WIFSTOPPED(status)   | 若为当前暂停子进程的返回的状态，则为真。对于这种情况，可执行WSTOPSIG(status),取使子进程暂停的信号编号。                 |
   | WIFCONTINUED(status) | 若在作业控制暂停后已经继续的子进程返回了状态，则为真。                                                                  |

   
   **暂停的进程也可以通过wait拿到状态?**
   
   waitpid 提供等待特定子进程结束的功能。
   对于waitpid函数中pid参数的作用解释如下：
   pid == -1      等待任一子进程，和wait作用相同。
   pid > 0        等待其进程ID与pid相等的子进程结束。
   pid == 0       等待其组ID等于调用进程组ID的任一子进程。
   pid < -1       等待其组ID等于pid绝对值的任一子进程。
   

   对于wait, 其唯一的出错是调用进程没有子进程(函数调用被一个信号中断时，也可能返回另一种出错)
   对于waitpid, 如果指定进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程则都将出错。
   
   options参数可以进一步控制waitpid的操作。此参数可以是0，也可以是下表中的常量按位"或"运算的结果。
   waitpid的options常量
   | 常量       | 说明                                                                                                                                                        |
   |------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | WCONTINUED | 若实现支持作业控制，那么由pid指定的任一子进程在暂停后已经继续，但其状态尚未报告，则返回其状态                                                               |
   | WNOHANG    | 若由pid指定的子进程并不是立即可用的，则waitpid不阻塞，此时返回值 为0                                                                                        |
   | WUNTRACED  | 若某实现支持作业控制，而由pid指定的任一子进程已处于暂停状态，并且其状态自暂停以来还未报告过，则返回其状态。WIFSTOPPED宏确定返回值是否对应地一个暂停子进程。 |
   
   waitpid提供了wait所没有的3个功能：
   1. 等待特定的进程。
   2. 提供了一个wait的非阻塞版本。
   3. waitpid支持作业控制。(WCONTINUED和WUNTRACED)

   **什么是报告?**
   >调用wait或waitpid获取状态？

   **什么是作用控制?**
   >控制正在运行的进程的行为。控制的shell命令有jobs,bg,fg,cmd& ,Ctrl+d, Ctrl+c, Ctrl+z。

** waitid函数
   比waitpid更灵活，更清晰。
   #include <sys/wait.h>
   int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
   
   waitid的idtype常量
   | 常量   | 说明                                                          |
   |--------+---------------------------------------------------------------|
   | P_PID  | 等待一个特定的进程:id包含要等待子进程的进程ID                 |
   | P_PGID | 等待一个特定进程组中的任一子进程:id包含要等待子进程的进程组ID |
   | P_ALL  | 等待任一子进程，忽略id                                        |
   
   options比waipid的options常量更多
   | 常量       | 说明                                                                            |
   |------------+---------------------------------------------------------------------------------|
   | WCONTINUED | 等待一个进程，它以前曾被暂停，此后又继续，但其状态尚未报告                      |
   | WEXITED    | 等待已退出的进程                                                                |
   | WNOHANG    | 如无有可用的子进程退出状态，立即返回而非阻塞                                    |
   | WNOWAIT    | 不破坏子进程的退出状态。该子进程退出状态可由后续的wait、waitid或waitpid调用取得 |
   | WSTOPPED   | 等待一个进程，它已经暂停，但其状态尚未报告                                      |
   
   infop参数指向siginfo结构的指针。该结构包含了有关引起子进程状态改变的生成信号的详细信息。

   可以这样类比理解：
   进程正常退出or异常退出时，内枋都会给父进程发送一个SIGCHLD信号。同时有一个队列存了该进程的终止状态。
   然后父进程可以通过wait调用来取得其终止状态，取得之后，其状态即从队列中移除。而父进程取其终止状态即上文的报告。
   而WNOWAIT参数是个特例，他取得状态后，并不称把状态从队列中移除。
   
** wait3和wait4函数
   比wait、waitpid、waitid功能多一个，这和参数rusage有关。r是resource的缩写。该参数要求内核返回由终止进程及其所有子进程使用的资源汇总。
   #include <sys/types.h>
   #include <sys/wait.h>
   #include <sys/resource.h>
   
   pid_t wait3(int *statloc, int options, struct rusage *rusage);
   pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);
   
   资源统计信息包括用户CPU时间总量、系统CPU时间总量、页面出错次数、接收到信号的次数等。
** 竞争条件
   本书中的定义：
   当多个进程都企图对 **共享数据** 进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了 **竞争条件**。
   
   如果在fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行，那么fork函数就会是竞争条件的滋生地。

   如果父进程希望等待一个子进程终止，可以用wait。
   如果子进程希望等待父进程终止，则可以用下面的循环:
   while(getppid() !=1)
       sleep(1);
   这种形式的循环(称为轮询(polling))的问题是它浪费了CPU时间。

   为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法。
   可以使用信号机制，也可以用各种形式的进程间通信(IPC)。

** exec函数
   exec只是用一个全新的程序替换了当前进程的正文、数据、堆和栈段。

   进程控制原语：
   fork 创建子进程
   exec 执行新程序
   exit退出进程
   wait等待进程退出
   
   #include <unistd.h>
   int execl(const char *pathname, const char *arg0, ... /* (char*)0 */);
   int execv(const char *pathname, char *const argv[]);
   int execle(const char *pathname, const char *arg0, ... /* (char*)0, char *const envp[] */);
   int execve(const char *pathname, char *const argv[], char *const envp[]);
   int execlp(const char *filename, const char *arg0, ... /* (char*)0 */);
   int execvp(const char *filename, char *const argv[]);
   
   这6个函数的记忆方法：
   字母p(path)表示该函数取filename作为参数，并且用PATH环境变量寻找可执行环境。
   字母l(list)表示该函数取一个参数表。
   字母v(vector)表示该函数取一个argv[]矢量。
   字母e(environ)表示该函数取envp[]数组，而不使用当前环境。

   在这6个函数中，只有execve是内核的系统调用。另外5个只是库函数，都会组织成最后调用系统调用。
   
   exec不只是保留了进程ID不变，还保留了以下内容：(可以对比fork）
   * 进程ID和父进程ID
   * 实际用户ID和实际组ID
   * 附加组ID
   * 进程组ID
   * 会话ID
   * 控制终端
   * 闹钟尚余留时间
   * 当前工作目录
   * 根目录
   * 文件模式创建屏蔽字
   * 文件锁(fork时，子进程不复制父进程的文件锁)
   * 进程信号屏蔽
   * 未处理信号
   * 资源限制
   * tms_utime、tms_stime、tms_cutime和tims_cstime值。


   对打开文件的处理和每个描述符的执行时关闭(close-on-exec)标志值有关（FD_CLOEXEC).若此值设置，则在执行exec时关闭描述符，否则保留为打开。
   系统默认设置为在执行exec后仍保持这种描述符打开。
   POSIX.1明确要求在执行exec时关闭打开的目录流。

   在执行exec前后实际用户ID和实际组ID不变。而有效用户ID和有效组ID取决于 所执行的程序文件的设置用户ID位和设置组ID位是否设置。
     
** 更改用户ID和组ID
   一般而言，在设计应用程序时，我们总是试图使用最小特权模型。
   #include <unistd.h>
   int setuid(uid_t uid);
   int setgid(gid_t gid);

   改变用户ID的规则：
   1. 若进程具有超级用户权限，则setuid函数将实际用户ID、有效用户ID、保存用户ID设置为uid。
   2. 若进程没有超级用户权限，但是uid等于实际用户ID或保存的设置用户ID,则setuid只将有效用户ID设置为uid, 不改变实际用户ID和保存的设置用户ID.
   3. 如果上面两个条件都不满足，则将errno设置为EPERM,并返回-1.

      
   关于内核所维护的三个用户ID,还要注意以下几点：
   1. 只有超级用户进程可以更改实际用户ID。通常，实际用户ID是在用户登录时，由login(1)程序设置的，而且永远不会改变它。
   2. 仅当对程序文件设置了设置用户ID位时，exec函数才会设置有效用户ID。任何时候都可以调用setuid,将有效用户ID设置为实际用户ID或保存的设置用户ID。
   3. 保存的设置用户ID是由exec复制有效用户ID而得来的。如果设置了文件的设置用户ID位，则在 exec根据文件的用户ID设置了进程的有效用户ID以后，就将这个副本保存下来。

      
   改变三个用户ID的不同方法
   | ID               | exec(设置用户ID位关闭) | exec(设置用户ID位打开) | setuid(uid)超级用户 | setuid(uid)非特权用户 |
   |------------------+------------------------+------------------------+---------------------+-----------------------|
   | 实际用户ID       | 不变                   | 不变                   | uid                 | 不变                  |
   | 有效用户ID       | 不变                   | 设置为程序文件的用户ID | uid                 | 设置为uid             |
   | 保存的设置用户ID | 从有效用户ID复制       | 从有效用户ID复制       | uid                 | 不变                  |

   参数man程序来理解。
*** setreuid和setregid函数
    r = real, e = effect
    用来交换实际用户ID和有效用户ID。
    #include <unistd.h>
    int setreuid(uid_t ruid, uid_t euid);
    int setregid(gid_t rgid, gid_t egid);
*** seteuid和setegid函数
    类似于setuid和setgid, 但只更改有效用户ID和有效组ID。
    
*** 组ID
    组ID的规则和用户ID一样。
** 解释器文件
   文本文件，其起始行是
   #！ pathname [optional-argument]
   平时看到的shell脚本，python脚本，ruby脚本都是这样的。。
   
   内核使调用exec函数的进程  实际执行的并不是该解释器文件, 而是该解释器文件第一行中pathname所指定的文件。

   基于以下理由，解释器文件是有用的:
   1. 有些程序是用某种脚本语言编写的脚本，解释器文件可将这一事实隐藏起来。
   2. 解释器脚本在效率方面也提供了好处。
   3. 解释器脚本使我们可以使用除/bin/sh以外的其他shell来编写shell脚本。
** system函数
   #include <stdlib.h>
   int system(const char *cmdstring);
   
   如果cmdstring是一个空指针，则仅当命令处理程序可用时，system返回非0值，用此特征判断操作系统是否支持system函数。
   因为system在其实现中调用了fork、exec和waitpid,因此有三种返回值:
   1. 如果fork失败或者waitpid返回除EINTR之外的出错，则system返回-1,而且errno设置了错误类型值。
   2. 如果exec失败(表示不能执行shell), 则其返回值如同shell执行了exit(127)一样。
   3. 否则所有3个函数都执行成功，并且system的返回值 是shell的终止状态，其格式已在waitpid中说明。
      

   使用system而不是直接使用fork和exec的优点是:system进行了所需的各种出错处理，以及各种信号处理。
*** 设置用户ID程序
    决不应该在一个设置用户ID程序中调用system， 这是一个安全方面的漏洞。
    
    如果一个进程正以特殊的权限(设置用户ID或设置组ID)运行，它又想生成另一个进程执行另一个程序，则它应当直接使用fork和exec,而且在fork之后、exec之前要改回到普通权限。
    设置用户ID或设置组ID程序决不应调用system函数。
** 进程会计
   需要注意，所有实现都有差别。
   acct用于启用和禁止进程会计。唯一使用这个函数的是accton(8)命令。会计记录写到指定的文件中，在Mac os x 中，是/var/account/acct
   
    typedef u_short comp_t;
    struct acct
    {
        char ac_flag;/* flag */
        char ac_stat; /* termination status (signal & core flag only) */

        uid_t ac_uid; /* real user ID */
        gid_t ac_gid; /* real group ID */
        dev_t ac_tty; /* controlling terminal */
        time_t ac_btime; /* starting calendar time */
        comp_t ac_utime; /* user CPU time (clock ticks) */
        comp_t ac_stime; /* system CPU time(clock ticks) */
        comp_t ac_etime; /* elapsed time (clock ticks) */
        comp_t ac_mem; /* average memory usage */
        comp_t ac_io; /* bytes transferred (by read and write) */
        comp_t ac_rw; /* blocks read or written */
                      /* (not present on BSD systems) */
        char ac_commm[8];/*command name , 大小看系统, mac 是10*/
    }
    
    其中ac_flag成员记录了进程执行期间的某些事件。见下表。
    | ac_flag | 说明                               |
    |---------+------------------------------------|
    | AFORK   | 进程是由fork产生的，但从未调用exec |
    | ASU     | 进程使用超级用户特权               |
    | ACOMPAT | 进程使用兼容模式                   |
    | ACORE   | 进程转储core                       |
    | AXSIG   | 进程由信号杀死                     |
    | AEXPND  | 扩展的会计条目                            |
    
    会计记录所需的各种数据都由内核保存在进程表中，并在新进程被创建时(fork)置初值。
    
    一个进程休眠的时间总量并不精确。
** 用户标识
   任何进程都可以得到实际和有效用户ID和组ID。
   然后通过getpwuid(getuid()), 获取登录名。
   如果一个用户有多个登录名，则可以通过getlogin函数取得此用户登录时使用的名字。
   #include <unistd.h>
   char *getlogin(void);

   如果调用此函数的进程没有连接到用户登录所用的终端，则本函数会失效。通常称此类进程为守护进程。
   在获知登录名后，就可以用getpwnam在口令文件中查找用户的相关记录。
  
** 进程时间
   我们可以测量三种时间：墙上时钟时间、用户CPU时间、系统CPU时间。
   #include <sys/times.h>
   clock_t times(struct tms *buf);

   struct tms {
       clock_t tms_utime;
       clock_t tms_stime;
       clock_t tms_cutime;/* user cpu time, terminated children;*/
       clock_t tms_cstime;/* system cpu time, terminated children;*/
   }
   
   times函数返回墙上时钟时间作为其函数值。
* 第九章 进程关系
** 终端登录
   终端可以是基于字符的终端、仿真简单的基于字符终端的图形终端，或者是运行窗口系统的图形终端。
*** BSD终端登录
    1. init进程读取/etc/ttys后，fork子进程exec执行gettty程序.
    2. gettty程序回显"login:", 等待用户输入登录名，gettty拿到登录名后，调用login程序。
    3. login 显示"Password:", 接收用户的输入。crypt(3)加密后和阴影口令文件中登录项的pw_passwd字段对比。
        如果密码连续几次错误。调用exit(1)。init进程得到SIGCHLD信号后，回到步骤1.
        如果登录成功，做下面的工作。
       * 将当前工作目录设置为 该用户的起始目录
       * 调用chown改变该终端的所有权，使登录用户成为它的所有者。
       * 将对该终端设备的访问权限改变为用户读和写。
       * 调用setgid以及initgropus设置进程的组ID。
       * 用login所得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME), 以及一个系统默认路径(PATH)。
       * login进程改变为登录用户的用户ID(setuid)并调用该用户的登录shell。如 execl("/bin/sh", "-sh", (char*)0);
    4. 登录Shell读取其启动文件:.profile(不同shell不一样)。这些启动文件会改变环境变量，加上很多环境变量。
*** Mac OS X
    同上。只是是图形终端。
*** Linux终端登录
    类似于BSD, /etc/ttys的说明文件 换成了/etc/inittab
*** Solaris终端登录
    支持两种登录方式。一类是上述的gettty, 另一个是ttymon。
    区别是gettty的登录shell其父进程是init进程。而ttymon中，登录shell的父进程是ttymon。
** 网络登录
   通过串行终端登录至系统和经由网络登录至系统两者之间的主要(物理上的)区别是：
   通过网络登录时，终端和计算机之间的连接不是点对点连接。

   为使同一个软件既能处理终端login,又能处理网络login.系统使用了一种称为伪终端的软件驱动程序，它访真串行终端的运行行为，并将终端操作映射为网络操作。
*** BSD网络登录
    作为系统启动的一部分，init调用一个shell, 使其执行shell脚本/etc/rd。由此shell脚本启动一个守护进程inetd。一旦此shell脚本终止，inetd的父进程就变成了init。
    inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork, 然后生成的子进程执行适当的程序。

    以telnet为例。
    1. init->/ect/rd -> inetd。
    2. inetd接收到telnet请求时，fork一个子进程，然后exec执行telnetd程序
    3. telnetd打开一个伪终端设备，并用fork分成两个进程。父进程处理网络连接的通信。子进程执行login程序，执行exec前，会把文件描述符0\1\2和伪终端相连。
    4. 如果登录成功。。和串行终端登录成功流程一样。
       
       
    当通过终端或网络登录时，我们得到一个登录shell，其标准输入、输出和标准出错连接到一个终端设备或者伪终端设备上。
    之后我们会了解到，登录shell是会话的开始，而此终端或伪终端则是会话的控制终端。
    
*** Mac OS X网络登录
    同BSD
*** Linux网络登录
    用xinetd替换了inetd,其它一样
*** Solaris网络登录
    基本和BSD一样
** 进程组
*** 定义
   每个进程除了有一个进程ID之外，还属于一个进程组。
   进程组是一个或多个进程的集合。每个进程组有一个唯一的进程组ID。
  
   getgprp()获取调用进程的进程组ID。
   #include <unistd.h>
   pid_t getgprp(void);
   
   getpgid获取指定进程的进程组ID,pid=0时，即为获取调用进程的进程组ID
   #include <unistd.h>
   pid_t getpgid(pid_t pid);
   
*** 作用
   进程组里的进程 通常与同一作业相关联，可以接收来自同一终端的各种信号。
   
*** 生命周期
     从进程组创建开始直到其中最后一个进程离开为止的时间区间称为进程组的生存期。进程组中的最后一个进程可以终止，或者转移到另一个进程组。
     setpgid用来加入一个现有的或者创建一个新进程组.
     #include <unistd.h>
     int setpgid(pid_t pid, pid_t pgid);
*** 进程与进程组关系：
     每个进程组都可以有一个组长进程。组长进程的标识是，其进程组ID等于其进程ID。
     组长进程可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。
     
     一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec函数之一后，它就不再能改变该子进程的进程组ID。
     
     在大多数作业控制shell中, 在fork之后调用setpgid函数，使父进程设置其子进程的进程组ID,并且使子进程设置其自己的进程组ID。
     之所以都调用，是为了确保在父、子进程认为子进程已进入了该进程组时，这确实已经发生了。如果不这样做的话，那么fork之后，由于父、子进程运行的先后次序不确定，会造成在一段时间内子进程
     组员身份不确定，这就产生了竞争条件。
     
** 会话
   会话是一个或多个进程组的集合。
   通常是由shell的管道线将多个进程编成一组的。如proc1 | proc2 | proc3
   
   进程调用setsid函数建立一个新会话。
   #include <unistd.h>
   pid_t setsid(void);

   如果调用此函数的进程不是一个进程组的组长，则此函数就会创建一个新会话，结果将发生下列三件事：
   1. 该进程变成新会话首进程(session leader)。此时该进程是新会话中的唯一进程。
   2. 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。
   3. 该进程没有控制终端。如之前有，联系会被中断。

      
   如果调用此函数的进程已经是一个进程组的组长，则此函数出错。 为了保证不会发生这种事情，通常先调用fork,然后使其父进程终止，而子进程则继续。
   
   通过getsid获取会话ID, 有时也叫“会话首进程”。
   #include <unistd.h>
   pid_t getsid(pid_t pid);
   出于安全考虑，某些实现会有如下限制：
   如若pid并不属于调用者所在的会话，那么调用者就不能得到该会话首进程的进程组ID。
   
** 控制终端
   会话和进程组有一些其他特性：
   1. 一个会话可以有一个控制终端。这通常是登录到其上的终端设备(在终端登录情况下)或伪终端设备(在网络登录情况下)。
   2. 建立与控制终端连接的会话首进程被称为控制进程。怎么建立????
   3. 一个会话中的几个进程组可被分成一个前台进程组  以及 一个或几个后台进程组
   4. 如果一个会话有一个控制终端，则它有一个前台进程组，会话中的其他进程组则为后台进程组。
   5. 无论何时键入终端的中断键(通常是DELETE或Ctrl+C), 就会将中断信号发送给前台进程组中的所有进程。
   6. 无论何时键入终端的退出键(通常是Ctrl+\), 就会将中断信号发送给前台进程组中的所有进程。
   7. 如果终端接口检测到调制解调器(或网络)已经断开连接，则将挂断信号发送给控制进程(会话首进程)。
      
      
   通常，我们不必关心控制终端，登录时，将自动建立控制终端。(控制进程都是登录shell?)
   
   保证程序能读写控制终端的方法是打开文件/dev/tty。
** tcgetpgrp、tcsetpgrp和tcgetsid函数
   用来通知内核哪一个进程组是前台进程组，这样终端设备驱动程序就能了解将终端输入和终端产生的信号送到何处。
   #include <unistd.h>
   pid_t tcgetpgrp(int filedes);//返回前台进程组ID,该前台进程组与在filedes上打开的终端相关联
   int tcsetpgrp(int filedes, pid_t pgrpid);
   
   大多数应用并不用这两个函数，它们通常由作业控制shell调用。
   tcgetsid获取会话首进程的进程组ID。
   #include <termios.h>
   pid_t tcgetsid(int filedes);
** 作业控制
   作业控制允许在一个终端上启动多个作业(进程组)，它控制哪一个作业可以访问该终端，以及哪些作业在后台运行。
   作业控制要求下面三种形式的支持：
   1. 支持作业控制的shell。
   2. 内核中的终端驱动程序必须支持作业控制。
   3. 内核必须提供对某些作业控制信号的支持。

      
   一个作业只是几个进程的集合，通常是一个进程的管道线。
   
   当启动一个后台作业时，shell赋予它一个作业标识，并打印一个或几个进程ID。
   
   shell并不在任何随意时刻打印后台作业的状态改变--它在只打印其提示符让用户输入新的命令行之前才这样做。

   有三个特殊字符可使终端驱动程序产生信号，并将它们送至前台进程组:
   * 中断字符(一般采用DELETE或Ctrl+C)一般产生SIGINT。
   * 退出字符(一般采用Ctrl+\)产生SIGQUIT。
   * 挂起字符(一般采用Ctrl+Z)产生SIGTSTP。
    
     
   后台进程也会产生两个信号。
   当后台进程读终端时，会产生SIGTTIN, 通常会暂时停止此后台作业。
   当后台进程写终端时，有两种情况，一种是允许写，另一种是不允许写，禁止写时，会由终端驱动程序向该作业发送SIGTTOU信号。

   是否需要作业控制是一个有争议的话题。不管如何，作业控制都是POSIX.1要求的功能。

** shell执行程序
   在Mac中，可以通过ps -o pid,ppid,pgid,sess,tpgid,command打印进程、进程组、会话和控制终端之间的关系。
   前台进程组ID是终端的一个属性，而不是进程的属性。如果ps发现此会话没有控制终端，则tpgid值为-1，否则为前台进程组ID。

   执行cat > temp.foo &
   在有作业控制时，作业控制被放到后台进程组中，如果后台作业试图读控制终端，则会产生信号SIGTTIN。
   在没有作业控制时，其处理方法是：如果该进程自己没有重定向标准输入，则shell自动将后台进程的标准输入重定向到/dev/null。
   读/dev/null则产生一个文件结束。这就意味着后台cat进程立即读到文件尾，并正常结束。
   
   执行ps -o pid,ppid,pgid, sid, comm | cat1 |cat2
   在不同shell中的区别：
   1. 在Bourne shell中。该管道线中的最后一个进程是shell的子进程，而执行管道线中其他命令的进程则是该最后一个进程的子进程
   2. 在Baourne-again shell是所有进程的父进程。
** 孤儿进程组
   一个其父进程已终止的进程称为孤儿进程，这种进程由init进程"收养"。
   POSIX.1将孤儿进程组定义为：
   该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。

   另一种描述如下：
   一个进程组不是孤儿进程组的条件是，该组中有一个进程，其父进程在属于同一个会话的另一个组中。


   POSIX.1要求向新的孤儿进程组中处于停止状态的每一个进程发送挂断信号(SIGHUP),接着又向其发送继续信号(SIGCONT)。
   在处理了挂断信号后，子进程继续。对挂断信号的系统默认处理是终止该进程。
   
   处于孤儿进程组中的后台进程组读终端时，read返回出错，并将其errno设置为EIO。在这里，内核不能用SIGTTIN停止它，否则此进程组中的进程再也不会继续。
** FreeBSD实现
   session结构
   tty结构, v-node结构
   pgrp结构：前台进程组
   proc结构
   
   为了找到特定会话的前台进程组，内核不得不从session结构开始，然后用s_ttyp得到控制终端的tty结构，接着用t_pgrp得到前台进程组的pgrp结构。
   
* 第十章 信号
** 引言
   信号是软件中断。信号提供了一种处理异步事件的方法。
** 信号概念
   Mac OS X 10.3以及Linux 2.4.22 支持31种不同的信号, 而solaris9则支持38种不同的信号。另外，Linux和Solaris都支持应用程序额外定义的信号。
   
   不存在编号为0的信号。kill函数对信号编号0有特殊的应用。POSIX.1将此信号编号值称为空信号。

   很多条件可以产生信号：
   * 当用户按某些按键时，引发终端产生的信号。(DELETE,Ctrl+C,Ctrl+\,Ctrl+Z)。这些键可以自定义。
   * 硬件异常产生信号：除数为0、无效的内存引用等。
   * 进程调用kill(2)函数可将信号发送到另一个进程或进程组。有限制：只能发送给同一用户的进程，或者发送信号的进程所有者是超级用户。
   * 用户可用kill(1)命令将信号发送给其他进程。
   * 当检测到某种软件条件发生，并应将其通知有关进程时也产生信号。例句SIGURG、SIGPIPE、SIGALRM。

     
   信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。
   可以要求内核在某个信号出现时按照下列方式之一进行处理:
   1. 忽略此信号。大多数都可以，但有两个不能忽略，他们是SIGKILL和SIGSTOP。原因是：它们向超级用户提供了使进程终止或停止的可靠方法。
      另外，有些如果忽略由硬件异常引发的异常(如除0),则进程的行为是未定义的。
   2. 捕捉信号。自定义信号处理函数。注意：不能捕捉SIGKILL和SIGSTOP信号。
   3. 执行系统默认动作。针对大多数信号的系统默认动作是终止进程。
      
      
   UNIX系统信号
   | 名字       | 说明                        | 默认动作       | 细节说明                                                                                                           |
   |------------+-----------------------------+----------------+--------------------------------------------------------------------------------------------------------------------|
   | SIGABRT    | 异常终止(abort)             | 终止+core      | 调用abort函数时产生此信号                                                                                          |
   | SIGALRM    | 超时(alarm)                 | 终止           | 调用alarm函数设置的计时器超时，由setitimer函数设置的间隔时间超时时，产生此信号                                     |
   | SIGBUS     | 硬件故障                    | 终止+core      | 指示一个实现定义的 **硬件故障**。当出现某些类型的内存故障时，实现常常产生此信号                                    |
   | SIGCANCEL  | 线程库内部使用              | 忽略           | Solaris线程库内部使用的信号                                                                                        |
   | SIGCHLD    | 子进程状态改变              | 忽略           | 在一个进程终止或停止时，将SIGCHLD信号发送给其父进程。                                                              |
   | SIGCONT    | 使暂停进程继续              | 继续/忽略      | 此作业控制信号被发送给需要继续运行，但当前处于停止状态的进程。                                                     |
   | SIGEMT     | 硬件故障                    | 终止+core      | 指示一个实现定义的 **硬件故障**。(emt = emulator trap)。 **和上面的SIGBUS的区别呢？**                              |
   | SIGFPE     | 算术异常                    | 终止+core      | 此信号表示算术运算异常，例如除以0,浮点溢出等。                                                                     |
   | SIGFREEZE  | 检查点冻结                  | 忽略           | 仅由Solaris定义。用于通知进程在冻结系统状态之前需要采取特定的动作。                                                |
   | SIGHUP     | 连接断开                    | 终止           | 如果终端接口检测到一个连接断开，则将此信号发送给与该终端相关的控制进程(会话首进程)                                 |
   | SIGILL     | 非法硬件指令                | 终止+core      | 此信号指示进程已执行一条非法硬件指令。                                                                             |
   | SIGINFO    | 键盘状态请求                | 忽略           | BSD信号                                                                                                            |
   | SIGINT     | 终端中断符                  | 终止           | 当用户按中断键(一般采用DELETE或Ctrl+C)时，终端驱动程序产生此号并送至前台进程组中的每一个进程。                     |
   | SIGIO      | 异步IO                      | 终止/忽略      | 指示一个异步IO事件。                                                                                              |
   | SIGIOT     | 硬件异常                    | 终止+core      | 指示一个实现定义的 **硬件故障**  (iot = input/output trap)                                                        |
   | SIGKILL    | 终止                        | 终止           | 这是两个不能被捕捉或忽略的信号之一。它向系统管理员提供了一种可以杀死任一进程的可靠方法。                           |
   | SIGLWP     | 线程库内部使用              | 忽略           | Solaris线程库内部使用                                                                                              |
   | SIGPIPE    | 写至无读进程的管道          | 终止           | 如果在写到管道时读进程已终止，则产生此信号。                                                                       |
   | SIGPOLL    | 可轮询事件                  | 终止           | 当在一个 可轮询设备 上发生 一特定事件 时产生此信号。                                                               |
   | SIGPROF    | 梗概时间超时(setitimer)     | 终止           | 当setitimer(2)函数设置的梗概统计间隔计时器已到期时产生此信号。                                                     |
   | SIGPWR     | 电源失效/重启               | 终止/忽略      | 依赖于系统。主要用于具有不间断电源(UPS)的系统。如果电源失效，则UPS起作用，而且通常软件会接到通知。                 |
   | SIGQUIT    | 终端退出符                  | 终止+core      | 当用户在终端上按退出键(一般是Ctrl+\)时，产生此信号，并送至前台进程组中的所有进程。                                 |
   | SIGSEGV    | 无效的内存引用              | 终止+core      | 此信号指示进程进行了一次无效的内存引用 (segv = segmentation violation)                                             |
   | SIGSTKFLT  | 协处理器栈故障              | 终止           | 此信号仅由Linux定义。                                                                                              |
   | SIGSTOP    | 停止                        | 暂停进程       | 作业控制信号，用于停止一个进程。类似于交互停止信号(SIGTSTP)，但是SIGSTOP不能被捕捉或忽略。                         |
   | SIGSYS     | 无效系统调用                | 终止+core      | 该信号指示一个无效的系统调用。                                                                                     |
   | SIGTERM    | 终止                        | 终止           | 这是由kill(1)命令发送的系统默认终止信号。                                                                          |
   | SIGTHAW    | 检查点解冻                  | 忽略           | 此信号仅由Solaris定义。                                                                                            |
   | SIGTRAP    | 硬件故障                    | 终止+core      | 指示一个实现定义的 **硬件故障** 。当执行断点指令时，实现常用此信号将控制转移至调试程序                             |
   | SIGTSTP    | 终端停止符                  | 暂停进程       | 交互式停止指令。Ctrl+Z                                                                                             |
   | SIGTTIN    | 后台读控制tty               | 暂停进程       | 当一个后台进程组中进程试图读其控制终端时，终端驱动程序产生此信号。有两种情况不产生。                               |
   | SIGTTOU    | 后台写至控制tty             | 暂停进程       | 当一个后台进程组中的进程试图写到其控制终端时。一个进程可以允许后台进程写控制终端，不允许时也有两种情况不产生此信号 |
   | SIGURG     | 紧急情况(套接字)            | 忽略           | 此信号通知进程已经发生了一个紧急情况。在网络连接上接收到带外的数据时，可选择产生此信号。                           |
   | SIGUSR1    | 用户定义的信号              | 终止           | 用户定义的信号，可用于应用程序。                                                                                   |
   | SIGUSR2    | 用户定义的信号              | 终止           | 用户定义的信号，可用于应用程序。                                                                                   |
   | SIGVTALRM  | 虚拟时间闹钟(setitimer)     | 终止           | 当一个由setitimer(2)函数设置的虚拟间隔时间到期时产生此信号。                                                       |
   | SIGWAITING | 线程库内部使用              | 忽略           | 此信号由Solaris线程库内部使用                                                                                      |
   | SIGWINCH   | 终端窗口大小改变            | 忽略           | 内核维持与每个终端或伪终端相关联的窗口大小。进程可以用ioctl函数得到或设置窗口的大小。                              |
   | SIGXCPU    | 超过CPU限制(setrlimit)      | 终止+core/忽略 | 如果进程超过了其软CPU时间限制，则产生SIGXCPU信号。                                                                 |
   | SIGXFSZ    | 超过文件长度限制(setrlimit) | 终止+core/忽略 | 如果进程超过了其软文件长度限制，则产生此限制。                                                                     |
   | SIGXRES    | 超过资源限制          | 忽略         | 此信号仅由Solaris定义。                                                                                            |
   
   在下列条件下并不会产生core文件:
   * 进程是设置用户ID的，而且当前用户并非程序文件的所有者。
   * 进程是设置组ID的，而且当前用户并非该程序的组所有者。
   * 用户没有写当前工作目录的权限。
   * 该文件已存在，而且用户对该文件设有写权限。
   * 该文件太大。
** signal函数
   UNIX系统的信号机制最简单的接口是signal函数。
   #include <signal.h>
   void (*signal(int signo, void(*func)(int)))(int);
   
   signal函数由ISO C定义。
   因为signal的语义与实现有关，所以最好使用sigaction函数代替signal函数。
   func的值是常量SIG_IGN、常量SIG_DFL或当接到此信号后要调用的函数的地址。SIG_IGN，向内核表示忽略此信号。SIG_DFL,表示接到此信号后的动作是系统默认动作。

   signal函数原型说明此函数需要两个参数，返回一个函数指针。
   使用typdef 重定义下，更清晰。
   typedef void Sigfunc(int);
   Sigfunc *signal(int, Sigfunc*);

   如果查看系统的头文件<signal.h>，则很可能会找到下列形式的声明：
   #define SIG_ERR (void (*)())-1
   #define SIG_DFL (void (*)())0
   #define SIG_IGN (void (*)())1
   这些常量可以代替"指向函数的指针，该函数需要一个整型参数，而且无返回值"
*** 程序启动
    当执行一个程序时，所有信号的状态都是系统默认或忽略。
    确切地讲，exec函数将原先设置为要捕捉的信号都更改为它们的默认动作。
    signal的缺陷：不改变信号的处理方式就不能确定信号的当前处理方式。sigaction可以确定。

*** 进程创建
    当一个进程调用fork时，其子进程继承父进程的信号处理方式。
** 不可靠的信号
   在早期的UNIX版本(例如V7)中，信号是不可靠的。
   不可靠在这里指的是，信号可能会丢失:一个信号发生了，但进程却可能一直不知道这一点。
   同时，进程对信号的控制能力也很差，它能捕捉信号或忽略它。有时用户希望通知内核阻塞一个信号：不要忽略该信号，在其发生时记住它，然后在进程做好准备时再通知它。
   这种阻塞能力在当时是不具备的。
   
   问题示例一：
   sig_int()
   {
      //1.首先，在早期的版本中， **在进程每次接到信号对其进行处理时，随即将该信号动作复位为默认值**, 所以需要下面的代码再注册。
      //这里是时间窗口，有可能在注册下面的signal之前，又一次发生了信号，然后执行了默认动作，而默认动作的行为是终止程序。从而导致程序非期待地结束。
      //2.为下次信号发生注册信号处理函数
      signal(SIGINT, sig_int);
      
      //处理信号
   }
   
   早期系统的另一个问题：在进程不希望某种信号发生时，它不能关闭该信号。
   问题示例二：
   int sig_int_flag; //用来判断信号是否发生过。
   main()
   {
       int sig_int();
       ...
       signal(SIGINT, sig_int);//注册信号处理函数
       ...
       while(sig_int_flag == 0)
       //这里同样有一个时间窗口。可能发生下列情况:
       //1.sig_int_flag==0, 2. 发生信号，然后进入sig_int处理。3. 信号处理完，进程唤醒，继续调用下面的pause()函数，休眠。等待唤醒。 而信号只发生一次，于是进程一直睡眠再不工作。
           pause();
   }
   sig_int()
   {
       signal(SIGINT, sig_int);
       sig_int_flag = 1;
   }
** 中断的系统调用
   早期UNIX系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其error被设置为EINTR。
   这样处理的理由是：因为一个信号发生了，进程捕捉到了它，这意味着已经发生了某种事情，所以是个应当唤醒阻塞的系统调用的好机会。
   
   为了支持这种特性，将系统调用分成两类：低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的一类系统调用，它们包括:
   * 在读某些类型的文件(管道、终端设备以及网络设备)时，如果数据并不存在则可能会使调用者永远阻塞。
   * 在写这些类型的文件时，如果不能立即接受这些数据，则也可能会使调用者永远阻塞。
   * 在打开某些类型文件，在某种条件发生之前也可能会使调用者阻塞(例如，打开终端设备，它要等待直到所连接的调制解调器应答了电话）。
   * pause(按照定义，它使调用进程休眠直至捕捉到了一个信号)和wait函数。
   * 某些ioctl操作。
   * 某些进程间通信函数。
     

   与被中断的系统调用 相关的问题是必须显式地处理出错返回。
   如下所示：
   again:
       if ((n=read(fd,buf,BUFFSIZE))<0)
       {
            if (errno == EINTR)
                goto again;
             //handel other errors
       }
       
       
       
  为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引入了某些被中断系统调用的自动重启动。自动重启动的系统调用包括ioctl、read、readv、write、writev、wait和waitpid。
  引入自动重启动的另一个理由是：有时用户并不知道所使用的输入、输出设备是否是低速设备。
  
** 可重入函数
   进程捕捉到信号并对其进行处理时，进程正在执行的指令会被临时中断，转而去处理该信号处理程序中的指令，返回继续处理之前被中断的指令。
   但是之前被中断的指令可能是malloc,getpwnam等，而信号处理函数也可能调用malloc,getpwnam，结果导致继续执行之前的malloc,getpwnam出错。malloc\getpwnam就是不可重入函数。
   相对应的就是可重入函数。
   Single UNIX Specification说明了保证可重入函数。一共有117个。
   不可重入的原因有：
   * 已知它们使用静态数据结构
   * 它们调用malloc或free
   * 它们是标准I/O函数。标准I/O库的很多实现都以不可重入的方式使用全局数据结构。
     
     
   应当了解，即使使用可重入函数，但是由于每个线程只有一个errno变量，所以信号处理程序可能会修改其原先值。
   因此，作为一个通用的规则，当在信号处理程序中调用可重入函数时，应当在其前保存，在其后恢复errno。
   
   若在信号处理程序中调用一个不可重入函数，则其结果是不可预见的。
** SIGCLD语义
   SIGCLD语义和SIGCHLD并不相同。
   对于SIGCLD的早期处理方式如下：
   1. 如果进程特地设置该信号的配置为SIG_IGN,则调用进程的子进程将不产生僵死进程。
      注意，这与其默认动作(SIG_DFL)"忽略"不同。代之以在子进程终止时，将其状态丢弃。如果调用进程随后调用一个wait函数，那么它将阻塞至所有子进程都终止，然后该wait会返回-1,
      并将其errno设置为ECHILD
   2. 如果将SIGCLD的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果是这样，则调用SIGCLD处理程序。
** 可靠信号术语和语义
   引发信号的事件可以是硬件异常、软件异常、终端产生的信号或调用kill函数。在产生了信号时，内核通常在进程表中设置一个某种形式的标志。
   当对信号采取了这种动作时，我们说向进程递送了一个信号。在信号产生和递送之间的时间间隔内，称信号是未决的(pending)。

   进程可以选用信号递送阻塞。如果为进程产生了一个选择为阻塞的信号，而且对该信号的动作是默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，
   直到该进程对此信号解除了阻塞，或者对该信号的动作改为忽略。
   
   内核在递送一个原来被阻塞的信号给进程时，才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用sigpending函数来判定哪些信号是设置
   为阻塞并处于未决状态的。

   如果在进程解除对某个信号的阻塞之前，这种信号发生了多次，POSIX.1允许系统递送该信号一次或多次，如果递送多次，则称是对这些信号进行了排队。但是除非支持POSIX.1实时扩展，
   否则大多数UNIX并不对信号排队。代之以UNIX内核只递送这种信号一次。

   如果有多个信号要递送给一个进程，POSIX.1并没有规定这些信号的递送顺序。但是POSIX.1的Rationale建议:在其他信号之前递送与进程当前状态有关的信号，例如SIGSEGV。
   
   每个进程都有一个信号屏蔽字，它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。由于可能超出32个信号，定义了一个新类型sigset_t。
   进程可以调用sigprocmask来检测和更改当前信号屏蔽字。
   
** kill和raise函数
   kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。
   #include <signal.h>
   int kill(pid_t pid, int signo);
   int raise(int signo);
   
   pid有4个形式，类似于waitpid中的pid。
   如果调用kill为调用进程产生信号，而且此信号是不被阻塞的，那么在kill返回之前，就会将signo或者某个其他未决的非阻塞信号传送至该进程。
** alarm和pause函数
   使用alarm函数可以设置一个计时器，在将来某个指定的时间该计时器会超时，产生SIGALRM信号，系统默认处理是终止该进程。
   #include <unistd.h>
   unsigned int alarm(unsigned int seconds);
   每个进程只能有一个闹钟时钟。如果再次设置，会更新时间，如seconds=0，则是取消闹钟。

   pause函数使调用进程挂起直到捕捉到一个信号。
   #include <unistd.h>
   int pause(void);
   只有执行了一次信号处理函数并从其返回时，pause才返回。在这种情况下，pause返回-1,并将errno设置为EINTR。
   
   使用alarm和pause，进程可使自己休眠一段指定的时间。alarm还常用于对可能阻塞的操作设置时间上限值。

** 信号集
   POSIX.1定义了数据类型sigset_t以包含一个信号集，并且定义了下列五个处理信号集的函数。
   #include <signal.h>
   int sigemptyset(sigset_t *set);//空集合
   int sigfillset(sigset_t *set);//全集合
   int sigaddset(sigset_t *set, int signo);
   int sigdelset(sigset_t *set, int signo);
   int sigismember(sigset_t *set, int signo);//判断是否在集合中。

   所有应用程序在使用信号集前，要对该信号集调用sigemptyset或sigfillset一次。这是因为C编译器将把未赋初值的外部和静态变量都初始化为0，而这是否与给定系统上信号集的实现
   相对应却不清楚。
** sigprocmask函数
   sigprocmask可以检测或更改信号屏蔽字，或者在一个步骤中同时执行这两个操作。这是仅为单线程的进程定义的。
   #include <signal.h>
   int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

   通过how来控制是增加，减少 还是设置信号屏蔽号。如果oset不为null, 则当前的信号屏蔽字通过oset返回。
   在调用sigprocmask后如果有任何未决的、不再阻塞的信号，则在sigprocmask返回前，至少会将其中一个信号递送给该进程。

** sigpending函数
   sigpending返回信号集，其中的各个信号对于调用进程是阻塞的而不能递送，因而也一定是当前未决的。该信号集通过set参数返回。
   #include <signal.h>
   int sigpending(sigset_t *set);

** sigaction函数
   sigaction修改和检查与指定信号相关联的处理动作，取代UNIX早期版本使用的signal函数。
   #include <signal.h>
   int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
   act用于修改，oact用于返回。
   
   struct sigaction {
       void (*sa_handler)(int);
       sigset_t sa_mask;/* additional signals to block */
       int sa_flags;
       void (*sa_sigaction)(int, siginfo_t *, void *);
   }
   
   在信号处理程序被调用时，操作系统建立的新信号屏蔽字包括正被传送的信号。
   一旦对给定的信号设置了一个动作，那么在调用sigaction显式地改变它之前，该设置就一直有效。
   
   处理每个信号的选项标志
   | 选项         | 说明                                                                                                   |
   |--------------+--------------------------------------------------------------------------------------------------------|
   | SA_INTERRUPT | 中断的系统调用不重启                                                                                   |
   | SA_NOCLDSTOP | 子进程是因为作业控制而停止，不产生SIGCHLD信号                                                        |
   | SA_NOCLDWAIT | 若signo是SIGCHLD，则当调用进程的子进程终止时，不创建僵死进程                                           |
   | SA_NODEFER   | 当捕捉到此信号时，在执行其信号捕捉函数时，系统不自动阻塞此信号。**对应早期不可靠信号**                 |
   | SA_ONSTACK   | 若用sigaltstack(2)声明了一替换栈，则将此信号递送给替换栈上的进程。                                     |
   | SA_RESETHAND | 在此信号捕捉函数的入口处，将此信号的处理方式复位为SIG_DFL,并清除SA_SIGINFO标志。**对应早期不可靠信号** |
   | SA_RESTART   | 由此信号中断的系统调用会自动重启动。                                                                   |
   | SA_SIGINFO   | 此选项对信号处理程序提供了附加信息：一个指向siginfo结构的指针和一个指向进程上下文标识符的指针          |
   
   sa_sigaction字段是一个替代的信号处理程序，当在sigaction结构中使用了SA_SIGINFO标志时，使用该信号处理程序。
   sa_handler和sa_sigaction只能二选一。

   struct siginfo {
       int si_signo;
       int si_errno;
       int si_code;/* addtion info (depends on signal)*/
       pid_t si_pid;
       uid_t si_uid;
       void *si_addr;
       int si_status;
       long si_band;
       /* possibly other fields also */
   }
   
   如若信号处理程序是用sigaction设置的，那么其默认方式是不重新启动系统调用。
** sigsetjmp和siglongjmp函数
   setjmp和longjmp在信号处理函数中使用存在一个问题。
   当捕捉到一个信号时，进入信号捕捉函数，此时当前信号被自动地加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序。
   如果用longjmp跳出信号处理程序，那么，对此进程的信号屏蔽字会产生什么呢？
   
   为了解决此问题，引入sigsetjmp和siglongjmp。在信号处理程序中进行非局部转移时应当使用这两个函数。

   #include <setjmp.h>
   int sigsetjmp(sigjmp_buf env, int savemask);
   void siglongjmp(sigjmp_buf env, int val);
   
   当savemask非0时，env会保存当前的信号屏蔽字。然后当调用siglongjmp返回时，会从其中恢复保存的信号屏蔽字。
   
   关于数据类型sig_atomic_t,它是由ANSI C定义的在写时不会被中断的变量类型。
   它意味着这种变量在具有虚存的系统上不会跨越页的边界，可以用一条机器指令对其进行存取。
   对于这种类型的变量总是包括ANSI类型修饰符volatile,其原因是：该变量将由两个不同的控制线--main函数和异步执行的信号处理程序存取。
** sigsuspend函数
   如果希望对一个信号解除阻塞，然后pause以等待以前被阻塞的信号发生。在阻塞和pause之间由于有时间窗口，是有可能
导致pause以后一直暂停，得不到信号唤醒的。
   为了解决这个问题，需要在一个原子操作中实现恢复信号屏蔽字，然后使进程睡眠，这种功能是由sigsuspend函数所提供的。
   #include <signal.h>
   int sigsuspend(const sigset_t *sigmask);

   在捕捉到一个信号或发生了一个会终止该进程的信号之前，该进程也被挂起。如果捕捉到一个信号而且从该信号处理程序返回，则sigsuspend返回，
并且该进程的信号屏蔽字设置为调用sigsuspend之前的值。

   sigsuspend的另一种应用是等待一个信号处理程序设置一个全局变量。
   可以用信号实现父子进程之间的同步。前文所说的TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT、WAIT_CHILD。
** abort函数
   使程序异常终止
   #include <stdlib.h>
   void abort(void);
   此函数将SIGABRT信号发送给调用进程。进程不应忽略此信号。

   ANSI C要求若捕捉到此信号而且相应信号处理程序返回，abort仍不会返回到其调用者。
   如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、longjmp或siglongjmp。
   让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需要的清除操作。如果进程并不在信号处理程序中终止自己，
   POSIX.1说明当信号处理程序返回时，abort终止该进程。
   
** system函数
   POSIX.2要求system忽略SIGINT和SIGQUIT,阻塞SIGCHLD。
   因为由system执行的命令可能是交互作用命令，以及因为system的调用者在程序执行时放弃了控制，
   等待该执行程序的结束，所以system的调用者就不应该接收这两个终端产生的信号。
   
   为了避免system创建的子进程结束时，system的调用者错误地认为自己的子进程结束，需要system阻塞SIGCHLD信号。
** sleep函数
   #include <unistd.h>
   unsigned int sleep(unsigned int seconds);
   
   此函数使调用进程被挂起直到:
   1. 已经过了seconds所指定的墙上时钟时间，或者
   2. 该进程捕捉到一个信号并从信号处理程序返回。 
    
** 作业控制信号
   有六个POSIX.1认为与作业控制有关的信号。
   * SIGCHLD 子进程已停止或终止
   * SIGCONT 如果进程已停止，则使其继续运行。
   * SIGSTOP 停止信号(不能被捕捉或忽略)。
   * SIGTSTP 交互停止信号。
   * SIGTTIN 后台进程组的成员读控制终端。
   * SIGTTOU 后台进程组的成员写控制终端。
     
     
   在作业控制信号间有某种相互作用。当对一个进程产生四种停止信号(SIGTSTP,SIGSTOP,SIGTTIN或SIGTTOU)中的任意一种时，对该进程的任一未决的
   SIGCONT信号就被丢弃。与之类似的是，当对一个进程产生SIGCONT信号时，对同一进程的任一未决的停止信号被丢弃。

** 其他特征
*** 信号名字
    有些系统提供数组
    extern char *sys_siglist[];
    数组下标是信号编号，数组中的元素是指向一个信号字符串名字的指针。
    这些系统通常也提供函数psignal
    #include <signal.h>
    void psignal(int signo, const char *msg);
    字符串msg输出到标准出错，后面跟着一个冒号和一个空格，再跟着对该信号的说明，最后是一个新行符。
* 第十一章 线程
** 引言
   一个进程中的所有线程都可以访问该进程的组成部件，如文件描述符和内存。
   无论何时，只要单个资源需要在多个用户间共享，就必须处理一致性问题。
   同步机制，用以防止多个线程查看到不一致的共享资源。
** 线程概念
   使用多线程的好处：
   1. 通过为每种事件类型的处理分配单独的线程，能够简化处理异步事件的代码。每个线程只在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单的多。
   2. 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享。而多个线程自动地可以访问相同的存储地址空间和文件描述符。
   3. 有些问题可以通过将其分解从而改善整个程序的吞吐量。在只有一个控制线程的情况下，单个进程需要完成多个任务时，实际上需要把这些任务串行化；有了多个控制线程，相互独立的
      任务的处理就可以交叉进行，只需要为每个任务分配一个单独的线程，当然只有在处理过程互不依赖的情况下，两个任务的执行才可以穿插进行。
   4. 交互的程序同样可以通过使用多线程实现响应时间的改善，多线程可以把程序中处理用户输入输出的部分与其他部分分开。
      
      
   线程包含了表示进程内执行环境必需的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调用优先级和策略、信号屏蔽字、errno变量 以及线程私有数据。
   进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本、程序的全局内存和堆内存、栈以及文件描述符。
   
   编译时测试宏_POSIX_THREADS判断是否支持线程。
   运行时把_SC_THREADS常数用于调用sysconf函数，动态判断是否支持线程。
** 线程标识
   线程ID只在它所属的进程环境中有效。
   pthread_t数据类型表示线程ID，是个结构，不是整形。因此需要用一个函数来比较两个线程ID
   #include <pthread.h>
   int pthread_equal(pthread_t tid1, pthread_t tid2);
   
   线程可以通过调用pthread_self函数获得自身的线程ID。
   #include <pthread.h>
   pthread_t pthread_self(void);
** 线程创建
   在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。新增的线程可以通过调用
   pthread_create函数创建。
   #include <pthread.h>
   int pthread_create(pthread_t *restrict attr, void *(*start_rtn)(void*), void *restrict arg);
   新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无类型指针参数arg。
   线程创建时并不能保证哪个线程会先运行：是新创建的线程，还是调用线程。新创建的线程可以访问
   进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。
** 线程终止
   如果在进程中的任意线程调用了exit、_Exit或_exit,那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，
   那么，发送到线程的信号就会终止整个进程。
   单个线程可以通过3种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。
   1. 线程可以简单地从启动例程中返回，返回值是线程的退出码。(有点类似main函数的return,进程的返回状态)
   2. 线程可以被同一进程中的其他线程取消。
   3. 线程调用pthread_exit。
   #include <pthread.h>
   void pthread_exit(void *rval_ptr);
   进程中的其它线程可以通过调用pthread_join函数访问到这个指针。
   #include <pthread.h>
   int pthread_join(pthread_t thread, void **rval_ptr)
   调用线程一直阻塞，直到指定的线程调用pthread_exit、从启动例程中返回或者被取消。
   如果线程简单地从它的启动例程返回，rval_ptr就包含返回码。如果线程被取消,由rval_ptr指向的内存单元就设置为 PTHREAD_CANCELED。
   
   pthread_create和pthread_exit函数的无类型指针参数能传递的数值可以不止一个，该指针可以传递包含更复杂信息的结构的地址，
   但是注意这个结构所使用的内存在调用者完成调用以后必须仍然是有效的，否则就会出现无效或非法内存访问。
   
   线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程。
   #include <pthread.h>
   int pthread_cancel(pthread_t tid);
   在默认情况下，pthread_cancel函数会使得由tid标识的线程的行为表现为如同调用了参数
为PTHREAD_CANCELED的pthread_exit函数，但是，线程可以选择忽略取消或者控制如何被取消。
注意pthread_cancel并不等待线程终止，它仅仅提出请求。

   线程可以安排它退出时需要调用的函数，这样的函数称为线程清理处理程序。
   一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序
与它们的注册时相反。
   #include <pthread.h>
   void pthread_cleanup_push(void (*rtn)(void *), void *arg);
   void pthread_cleanup_pop(int execute);
   
   当线程执行以下动作时，清理函数rtn是由pthread_cleanup_push函数调度的，调用时只有一个参数arg:
   * 调用pthread_exit时;
   * 响应取消请求时;
   * 用非零execute参数调用pthread_cleanup_pop时。
     如果execute参数设置为0，清理函数将不被调用。不管发生上述哪种情况，pthread_cleanup_pop
都将删除上次pthread_cleanup_push调用建立的清理处理程序。

   线程函数和进程函数对比
   | 进程原语 | 线程原语            | 描述                         |
   |----------+---------------------+------------------------------|
   | fork     | pthread_create      | 创建新的控制流               |
   | exit     | pthread_exit        | 从现有的控制流中退出         |
   | waitpid  | pthread_join        | 从控制流中得到退出状态       |
   | atexit   | pthread_cleanup_push | 注册在退出控制流时调用的函数 |
   | getpid   | pthread_self        | 获取控制流的ID               |
   | abort    | pthread_cancel      | 请求控制流的非正常退出       |
   
   在默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经
   被分离，线程的底层存储资源可以在线程终止时立即被收回。在线程被分离后，我们不能
用pthread_join函数等待它的终止状态，因为对分离状态调用pthread_join会产生未定义行为。
可以调用phread_detach分离线程。
#include <pthread.h>
int pthread_detach(pthread_t tid);
**为什么需要分离线程**
因为线程不分离的话，需要等待创建线程调用pthread_join之后，才会释放存储资源。
而分离的线程在线程终止时，底层存储资源立即被回收。
** 线程同步
   当一个线程修改变量时，其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改
时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。

    考虑变量增量操作的情况，增量操作通常分解为以下3步。
    1. 从内存单元读入寄存器。
    2. 在寄存器中对变量做增量操作。
    3. 把新的值写回内存单元。

    如果数据总是以顺序一致出现的，就不需要额外的同步。当多个线程观察不到数据的不一致
时，那么操作就是顺序一致的。在现代计算机系统中，存储访问需要多个总线周期，多处理器
的总线周期通常在多个处理器上是交叉的，所以我们并不能保证数据是顺序一致的。

除了计算机体系结构的因素以外，程序使用变量的方式也会引起竞争，也会导致不一致的情况发生。
*** 互斥量
    互斥量从本质上来说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。
    ps: 感觉互斥量就是一个锁的标识。关键点在锁上。同时依赖程序的使用方式，必须对共享资源都使用同一把锁。锁的什么共享资源也是由程序控制的。锁只是一个机制，关键还是在于使用是否
得当。
    
    在设计时需要规定所有的线程必须遵守相同的数据访问规则，只有这样，互斥机制才能正常工作。操作系统并不会做数据访问的串行化。
    如果允许其中的某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他的线程在使用共享资源前都获取了锁，也还是会出现数据不一致的问题。
    
    互斥变量用pthread_mutex_t 数据类型表示，在使用之前，必须先初始化，可以设置为常量PTHREAD_MUTEX_INITIALIZER(只对静态分配的互斥量),
    也可以通过调用pthread_mutex_init函数进行初始化。如果动态地分配互斥量，那么在释放前需要调用pthread_mutex_destroy。
    #include <pthread.h>
    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
    int pthread_mutex_destroy(pthread_mutex_t *mutex);
    
    加锁，释放锁。
    #include <pthread.h>
    int pthread_mutex_lock(pthread_mutex_t *mutex);
    int pthread_mutex_trylock(pthread_mutex_t *mutex);
    int pthread_mutex_unlock(pthread_mutex_t *mutex);
    
*** 避免死锁
    如果线程试图对同一个互斥量加锁两次，那么它自身就会陷入死锁状态。还有使用多个锁时，两个线程
    互相等待对方释放锁，也会产生死锁。

    可以通过仔细控制互斥量的顺序来避免死锁的产生。例如，假设需要对两个互斥量A和B同时加锁。
    如果所有线程总是对互斥量B加锁之前锁住互斥量A,那么使用这两个互斥量就不会产生死锁(当然在其他
    资源上扔可能出现死锁)。
    
    有时候，应用程序的结构使得对互斥量进行排序是很困难的。如果涉及了太多的锁和数据结构，可用的函数
并不能把它转换成简单的层次，那么就需要采用另外的方法。
    在这种情况下，可以先释放占有的锁，然后过一段时间再试。这种情况下可以使用pthread_mutex_trylock接口
    来避免死锁。如果已经占有某些锁而且pthread_mutex_trylock接口返回成功，那么就可以前进。但是，
    如果不能获取锁，可以先释放已经占有的锁，做好清理工作，然后过一段时间再重新试。
    
*** 函数pthread_mutext_timelock
    相对于pthread_mutex_lock一直阻塞直到得到锁，pthread_mutex_timelock可以指定可以等待的时间。
    如果在指定等待的时间里没有得到锁，也会返回。此时返回错误码ETIMEOUT。
    #include <pthread.h>
    #include <time.h>
    int pthread_mutex_timelock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);
*** 读写锁
    读写锁与互斥量类似，不过读写锁允许更高的并行性。
    互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。
    读写锁可以有3种状态：读模式下的加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，
    但是多个线程可以同时占有读模式的读写锁。
    
    读写锁也叫共享互斥锁。读模式下锁住，也叫以共享模式锁住，写模式下锁住，也叫以互斥模式锁住。
    以共享模式锁住时，其它线程依然可以获取读模式的读写锁, 如果有一个线程以写模式来获取读写锁，会一直阻塞到所有占用读模式的线程释放锁,
    同时会阻塞之后读模式读写写的请求，避免等待的写模式锁请求一直得不到满足。

    以互斥模式锁住时，其它线程再获取读写锁(读/写模式)都会阻塞。
    
    与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁。
    #include <pthread.h>
    int  pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);
    int  pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
    如果默认属性就足够的话，可以用PTHREAD_RWLOCK_INITIALIZER常量对静态分配的读写锁进行初始化。
    
    如果pthread_rwlock_init为读写锁分配了资源，pthread_rwlock_destroy将释放这些资源。
    如果在调用pthread_rwlock_destroy之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失。
    
    锁
    #include <pthread.h>
    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
    
    同样有尝试锁，避免阻塞
    #include <pthread.h>
    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
    
*** 带有超时的读写锁
    类似于互斥量的带超时的锁，注意超时指的绝对时间，而不是相对时间
    #include <pthread.h>
    #include <time.h>
    int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);
    int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);
*** 条件变量
    条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。
    和互斥量和读写锁类似，使用前需要初始化。
    如果是静态分配的，可以用PTHREAD_COND_INITIALIZER初始化。
    如果是动态分配的，可以用pthread_cond_init函数进行初始化。同时需要在释放底层的内存空间之前，使用pthread_cond_destroy()去除初始化。
    #include <pthread.h>
    int pthread_cond_init(pthread_cond_t *restrict cond, pthread_condattr_t *restrict attr);
    int pthread_cond_destroy(pthread_cond_t *cond);
    
    使用pthread_cond_wait等待条件变为真。
    #include <pthread.h>
    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
    int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict timeout);
    
    传递给pthread_cond_wait的互斥量对条件进行保护，调用者把锁住的互斥量传给函数。
    函数把调用线程放到等待条件的线程列表上，然后对互斥量解锁，这两个操作是原子操作。pthread_cond_wait返回时，互斥量再次被锁住。
    从pthread_cond_wait或者pthread_cond_timedwait调用成功返回时，线程需要重新计算条件，因为其他线程可能已经在运行并改变了条件。

    有两个函数用于通知线程条件已经满足。pthread_cond_signal唤醒单个线程。pthread_cond_broadcast唤醒所有线程。允许pthread_cond_signal在实现的时候
    可以唤醒不止一个线程。这两个函数，也称为向线程或条件发送信号。。

    貌似信号是唯一的异步事件，其它机制都是通过信号来完成的。
*** 自旋锁
    自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等
    (自旋)阻塞状态。自旋锁可用于以下情况：锁被持有的时间短，而且线程并不希望在重新
    调度上花费太多的成本。
    **抢占式内核和非抢占式内核的区别?**
    这里抢占的是CPU资源。
    内核抢占(可抢占式内核):
    即当进程位于内核空间时，有一个更高优先级的任务出现时，如果当前内核允许抢占，
    则可以将当前任务挂起，执行优先级更高的进程。
    非抢占式内核：
    高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占CPU运行。进程一旦处于极心态(例如用户进程执行系统调用),
    则除非进程自愿放弃CPU,否则该进程将一直运行下去，直至完成或退出内核。
    
    当自旋锁用在非抢占式内核中是非常有用的：除了提供互斥机制以外，它们会阻塞中断，这样中断处理程序就
    不会让系统陷入死锁状态，因为它需要获取已被加锁的自旋锁(把中断想成另一种抢占)。在这种类型的
    内核中，中断处理程序不能休眠，因此它们能用的同步原语只能是自旋锁。
    
    自旋锁只在某些特定的情况下有用。???哪种特定情况???

    #include <pthread.h>
    int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
    int pthread_spin_destroy(pthread_spinlock_t *lock);
    pshared有两个取值：PTHREAD_PROCESS_SHARED,自旋锁能被可以访问锁底层内存的线程获取，即使那些线程
    属于不同的进程。
    PTHREAD_PROCESS_PRIVATE,自旋锁只能被初始化该锁的进程内部的线程所访问。

    #include <pthread.h>
    int pthread_spin_lock(pthread_spinlock_t *lock);
    int pthread_spin_trylock(pthread_spinlock_t *lock);
    int pthread_spin_unlock(pthread_spinlock_t *lock);
    
    pthread_spin_trylock不能自旋。不能锁立即返回EBUSY错误。
    需要注意：不要调用在持有自旋锁情况下可能会进入休眠状态的函数。如果调用了这引起函数，会
    浪费CPU资源，因为其他线程需要获取自旋锁需要等待的时间就延长了。
*** 屏障
    屏障(barrier)是用户协调多个线程并行工作的同步机制。屏障允许每个线程等等，直到所有的合作线程都
    到达某一点，然后从该点继续执行。
    屏障允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以
    接着工作。
    #include <pthread.h>
    int pthread_barrier_init(pthread_barrier_t *restrict barrier,const pthread_barrierattr_t *restirct attr, unsigned int count);
    int pthread_barrier_destroy(pthread_barrier_t *barrier);

    ccount指定屏障计数。
    #include <pthread.h>
    int pthread_barrier_wait(pthread_barrier_t *barrier);
    调用pthread_barrier_wait的线程在屏障计数未满足条件时，进入休眠状态。如果满足屏障计数，
    所有的线程都被唤醒。
    其中一个线程会返回PTHREAD_BARRIER_SERIAL_THREAD，剩下的线程看到的返回值是0,这可以控制其中一个线程
    作为主线程，它可以工作在其他线程已经完成的工作结果上。
* 第十二章 线程控制
** 线程限制
   sysconf，线程方面有4个限制。
   | 限制名称                      | 描述                                                 | name参数                         |
   |-------------------------------+------------------------------------------------------+----------------------------------|
   | PTHREAD_DESTRUCTOR_ITERATIONS | 线程退出时操作系统实现试图销毁线程特定数据的最大次数 | _SC_THREAD_DESTRUCTOR_ITERATIONS |
   | PTHREAD_KEYS_MAX              | 进程可以创建的键的最大数目                           | _SC_THREAD_KEYS_MAX              |
   | PTHREAD_STACK_MIN             | 一个线程的栈可用的最小字节数                         | _SC_THREAD_STACK_MIN             |
   | PTHREAD_THREADS_MAX           | 进程可以创建的最大线程数                             | _SC_THREAD_THREADS_MAX           |
** 线程属性
   pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常，管理这些属性的函数都遵循相同的模式。
   1. 每个对象与它自己类型的属性对象进行关联(线程与线程属性关联，互斥量与互斥量属性关联等等）。属性对象对应用程序来说是不透明的。
   2. 有一个初始化函数，把属性设置为默认值。
   3. 还有一个销毁属性对象的函数。如果初始化函数分配了与属性对象关联的资源，销毁函数负责释放这些资源。
   4. 每个属性都有一个从属性对象中获取属性性的函数。
   5. 每个属性都有一个设置属性值的函数。
   
   线程属性见下表
   | 名称        | 描述                               |
   |-------------+------------------------------------|
   | detachstate | 线程的分离状态属性                 |
   | guardsize   | 线程栈末尾的警戒缓冲区大小(字节数) |
   | stackaddr   | 线程栈的最低地址                   |
   | stacksize   | 线程栈的最小长度(字节数)                     |
   
   线程还有其他的一些属性，这些属性并没有在pthread_attr_t结构中表达：
   * 可取消状态
   * 可取消类型
   * 并发度
     
     
   并发度控制着用户级线程可以映射的内核线程或进程的数目。如果操作系统的实现在内核级线程和用户级的线程之间保持一对一的映射，
   那么改变并发度并不会有效果。
   如果是多对一的话，增加并发度，可能会改善性能。
   #include <pthread.h>
   int pthread_getconcurrency(void);
   int pthread_setconcurrency(int level);
   level=0是系统决定。pthread_setconcurrency也只是向系统建议，系统并不保证请求的并发度一定会被采用。
** 同步属性
*** 互斥量属性
    pthread_mutexattr_t结构。
    值得注意的3个属性是:进程共享属性、健壮属性以及类型属性。
    互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着，当持有互斥量的进程终止时，
    需要解决互斥量状态恢复的问题。这种情况发生时，互斥量处于锁定状态，恢复起来很困难。
    其他阻塞在这个锁的进程将会一直阻塞下去。
    pthread_mutexattr_getrobust和pthread_mutextattr_setrobust获取和设置健壮属性。
    robust = 健壮
    
    pthread_mutexattr_t结构。
    #include <pthread.h>
    int pthread_mutexattr_init(pthread_mutexattr_t *attr);
    int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
    共享属性：
    #include <pthread.h>
    int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict attr, int *restrict pshared);
    int pthread_mutexattr_setpshared(const pthread_mutexattr_t *restrict attr, int pshared);
    
    默认属性为PTHREAD_PROCESS_PRIVATE
    取值为PTHREAD_PROCESS_SHARED时，从多个进程共享的内存区域中分配的互斥量就可以用于这些进程的同步。

    类型互斥量属性。有3类，见下面的描述
    | 互斥量类型               | 没有解锁时再次加锁? | 不占用时解锁? | 在已解锁时解锁? |
    | PTHREAD_MUTEX_NORMAL     | 死锁                | 未定义        | 未定义          |
    | PTHREAD_MUTEX_ERRORCHECK | 返回错误            | 返回错误      | 返回错误        |
    | PTHREAD_MUTEX_RECURSIVE  | 允许                | 返回错误      | 返回错误        |
    | PTHREAD_MUTEX_DEFAULT    | 未定义              | 未定义        | 未定义          |
    #include <pthread.h>
    int pthread_mutexattr_gettype(const pthread_mutexattr_t  *restrict attr, int *restrict type);
    int pthread_mutexattr_settype(const pthread_mutexattr_t  *attr, int type);
    
    注意:递归类型互斥量锁不能用于条件变量中,因为pthread_cond_wait解锁要求立即释放掉锁，以便其它线程拿到锁后修改条件，再通知。
*** 读写锁属性
    POSIX只定义了进程共享属性.
*** 条件变量属性
    同样是支持进程共享属性
*** 屏障属性
** 重入
   线程在遇到重入问题时与信号处理程序是类似的。在这两种情况下，多个控制线程在相同的
   时间有可能调用相同的函数。

   如果一个函数在相同的时间点可以被多个线程安全地调用，就称该函数是线程安全的。

   支持线程安全函数的操作系统实现会在<unistd.h>中定义符号_POSIX_THREAD_SAFE_FUNCTIONS。
   
   很多函数并不是线程安全的，因为它们返回的数据存放在静态缓冲区中。通过修改接口，要求调用者
   自己提供缓冲区可以使函数变为线程安全的。

   posix.1列出79个函数是不可重入的。

   如果一个函数对多个线程来说是可重入的，就说这个函数是线程安全的。但这并不能说明对信号处理
   程序来说该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的，那么就可以说函数
   是异步信号安全的。
   
** 线程特定数据
   线程特定数据，也称为线程私有数据，是存储和查询某个特定线程相关数据的一种机制。我们把这种
   数据称为线程特定数据或线程私有数据的原因是，我们希望每个线程可以访问它自己单独的数据副本，
   而不需要担心与其他线程的同步访问问题。

   引入线程私有数据的原因：
   1. 有时候需要维护基于每个线程的数据。防止某个线程的数据与其他线程的数据相混淆。
   2. 提供了让基于进程的接口适应多线程环境的机制。一个很明显的实例是errno。
      
     
   一个进程中的所有线程都可以访问这个进程的整个地址空间。除了使用寄存器以外，一个线程没有办法
   阻止另一个线程访问它的数据。线程特定数据也不例外。
   在分配线程特定数据之前，需要创建与该数据相关联的键。(可以和IOS的associate关联一下)
   #include <pthread.h>
   int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void*));
   这个键可以被进程中的所有线程使用，但每个线程把这个键与不同的线程特定数据地址进行关联。
   创建新键时，每个线程的数据地址设为空值。
   #include <pthread.h>
   int pthread_key_delete(pthread_key_t key);

   解决竞争有个办法是使用pthread_once(可以和IOS中的dispatch_once关联一下)
   #include <pthread.h>
   pthread_once_t initflag = PTHREAD_ONCE_INIT;
   int pthread_once(pthread_once_t *initflag, void (*initfn)(void));
   initflag必须是一个非本地变量(如全局变量或静态变量)，而且必须初始化为PTHREAD_ONCE_INIT。

   键一旦创建以后，就可以通过调用pthread_setspecific函数把键和线程特定数据关联起来。可以
   通过pthread_getspecific函数获得线程特定数据的地址。
   #include <pthread.h>
   void *pthread_getspecific(pthread_key_t key);
   int pthread_setspecific(pthread_key_t key, const void *value);
** 取消选项
   有两个线程属性并没有包含在pthread_attr_t结构中，它们是可取消状态和可取消类型。
   这两个属性影响着线程在响应pthread_cancel函数调用时所呈现的行为。
   可取消状态属性候选值有PTHREAD_CANCEL_ENABLE和PTHREAD_CANCEL_DISABLE。
   线程通过调用pthread_setcancelstate修改它的可取消状态。
   #include <pthread.h>
   int pthread_setcancelstate(int state, int *oldstate);
   
   线程在取消请求发出以后还是继续运行，直到线程达到某个取消点。取消点是线程检查它是否被取消
   的一个位置，如果取消了，则按照请求行事。POSIX.1定义了42个函数，取消点会出现。
   可以调用pthread_testcancel函数在程序中添加自己的取消点。
   #include <pthread.h>
   void pthread_testcancel(void);

   取消类型有两个PTHREADCANCEL_DEFERRED和PTHREAD_CANCEL_ASYNCHRONOUS。
   通过pthread_setcanceltype来修改类型。
   #include <pthread.h>
   int pthread_setcanceltype(int type, int *oldtype);
   使用异步取消时，线程可以在任意时刻撤消，不是非得遇到取消点才能被取消。
** 线程和信号
   每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。
   进程中的信号是递送到单个线程的。如果一个信号与硬件故障相关，那么该信号一般会被发送到
   引导该事件的线程中去，而其他的信号则被发送到任意一个线程。
   
   sigprocmask的行为在多线程的进程并没有定义，线程必须使用pthread_sigmask。
   #include <signal.h>
   int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);
   
   线程可以通过调用sigwait等待一个或多个信号的出现。
   #include <signal.h>
   int sigwait(const sigset_t *restrict set, int *restrict signop);
   为了避免错误行为发生，线程在调用sigwait之前，必须阻塞那些它正在等待的信号。
   sigwait函数会原子地取消信号集的阻塞状态，直到有新的信号被递送。
   使用sigwait的好处在于它可以简化信号处理，允许把异步产生的信号用同步的方式处理。
   
   如果多个线程在sigwait的调用中因等待同一个信号而阻塞，那么在信号递送的时候，就只有一个线程
   可以从sigwait中返回。
   在同时有sigwait和sigaction时(处理的同一个信号),操作系统可以让sigwait返回，也可以激活信号
   处理程序，但这两种情况不会同时发生。
   
   kill把信号发送给进程。要把信号发送给线程，可以调用pthread_kill
   #include <signal.h>
   int pthread_kill(pthread_t thread, int signo);
   通过传一个0值的signo来检查线程是否存在。
   
   注意：闹钟定时器是进程资源，并且所有的线程共享相同的闹钟。所以，进程中的多个线程
   不可能互不干扰地使用闹钟定时器。
** 线程和fork
   当线程调用fork时，就为子进程创建了整个进程地址空间的副本。
   子进程通过继承整个地址空间的副本，也从父进程那里继承了所有互斥量、读写锁和条件变量的状态。如果父进程
   包含多个线程，子进程在fork返回以后，如果紧接着不是马上调用exec的话，就需要清理锁状态。
   在进程内部只存在一个线程，它是由父进程中调用fork的线程的副本构成的。如果父进程中的线程占有锁，子进程同样占有这些锁。
   问题是子进程并不包含占有锁的线程的副本，所以子进程没有办法知道它占有了哪些锁并且需要释放哪些锁。

   要清除锁的状态，可以通过调用pthread_atfork函数建立fork处理程序。
   #include <pthread.h>
   int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
   prepare fork处理程序由父进程在fork创建子进程前调用，这个fork处理程序的任务是获取父进程定义的所有锁。
   parent fork处理程序是在fork创建了子进程后，但在fork返回前在父进程环境中调用的。任务是解锁。
   child fork处理程序在fork返回之前 在子进程环境中调用，目的也是解锁。

   可以多次调用pthread_atfork函数从而设置多套fork处理程序。
** 线程和I/O
   pread和pwrite是为了避免在多线程下读写文件(由于共享文件描述符)导致的异常，而提供了原子定位并读 和 原子定位并写的操作。
* 第十三章 守护进程
** 守护进程的特征
   ps -axj可以打印相关进程状态
   -a显示由其他用户所拥有的进程的状态，-x显示没有控制终端的进程状态，-j显示与作业有关的信息：会话ID、进程组ID、控制终端以及
   终端进程组ID。

   父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。(init是个例外，它是一个由内核在引导装入时启动
   的用户层次的命令.)
   内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户特权运行，无控制终端，无命令行。
   
   rpcbind守护进程提供将远程过程调用(RPC)程序号映射为网络端口号的服务。
   rsyslogd守护进程可以被由管理员启动的将系统消息记入日志的任何程序使用。
   inetd守护进程，它侦听系统网络接口，以便取得来自网络的对各种网络服务进程的请求。
   nfsd、nfsiod、lockd、rpciod、rpc.idmapd、rpc.statd和rpc.mountd守护进程提供对网络文件系统的支持。
   前4个是内核守护进程，后3个是用户级守护进程。
   cron守护进程在定期安排的日期和时间执行命令，主要执行重复的命令。
   atd，在指定的时间执行任务，只执行一次。
   sshd守护进程提供了安全的远程登录和执行设施。
   
   大多数守护进程都是以超级用户特权运行。所有的守护进程都没有控制终端，其终端名设置为问号。
   内核守护进程以无控制终端方式启动，用户层守护进程缺少控制终端可能是守护进程调用了setsid的结果。
   用户层守护进程的父进程是init进程。
   
** 编程规则
   经验规则：
   1. 首先要做的是调用umask将文件模式创建屏蔽字设置为一个已知值(通常是0)。由继承得来的文件模式创建屏蔽字
      可能会被设置为拒绝某些权限。
   2. 调用fork,然后使父进程exit。这样做实现了下面几点。第一，如果该守护进程是作为一条简单的shell命令启动的，那么
      父进程终止会让shell认为这条命令已经执行完毕。第二，虽然子进程继承了父进程的进程组ID,但获得了一个新的进程ID,
      这就保证了子进程不是一个进程组的组长长进程。这是下面将要进得的setsid调用的先决条件。
   3. 调用setsid创建一个新会话。使进程:a 成为新会话的首进程 b、成为一个新进程组的组长进程。c、没有控制终端
   4. 将当前工作目录更改为根目录。从父进程处继承过来的当前工作目录可能是一个挂载的文件系统中。
      因为守护进程通常是在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，
      那么该文件系统就不能被卸载。
   5. 关闭不再需要的文件描述符。
   6. 某些守护进程打开/dev/null使其具有文件描述符0、1、2.这样，任何一个试图读标准输入、写标准输出或标准错误的库例程
      都不会产生任何效果。
** 出错记录
   syslog
   有以下3种产生日志消息的方法。
   1. 内核例程可以调用log函数. 用户进程可以读写/dev/klog设备
   2. 大多数用户进程(守护进程)调用syslog函数来产生日志消息。消息被发送至UNIX域数据报套接字/dev/log
   3. 无论一个用户进程是在此主机上，还是在通过TCP/IP网络连接到此主机的其他主机上，都可将日志消息发送UDP端口514。
      
     
   syslogd守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件，其文件名一般为/etc/syslog.conf,
   该文件决定了不同种类的消息应送向何处。
   #include <syslog.h>
   void openlog(const char *ident, int option, int facility);
   void syslog(int priority, const char *format, ...);
   void closelog(void);
   int setlogmask(int maskpri);
   
   除了syslog,很多平台还提供它的一种变体来处理可变参数列表。
   #include <syslog.h>
   #include <stdarg.h>
   void vsyslog(int priority, const char *format, va_list arg);
   
   大多数syslog实现将使消息短时间处于队列中。如果在此段时间中有重复消息到达，那么syslog守护进程不会把它写到日志记录中。
** 单实例守护进程
   文件和记录锁机制为一种方法提供了基础，该方法保证一个守护进程只有一个副本在运行。
   如果每一个守护进程创建一个有固定名字的文件，并在该文件的整体上加一把写锁，那么只允许创建一把这样的写锁。
   在此之后创建写锁的尝试都会失败，这向后续守护进程副本指明已有一个副本在运行。
       文件和记录锁提供了一种方便的互斥机制。如果守护进程在一个文件的整体上得到一把写锁，那么在该守护进程终止时，
   这把锁将被自动删除。不需要考虑清理工作。
** 守护进程的惯例
   在UNIX系统中，守护进程遵循下列通用惯例。
   1. 若守护进程使用锁文件，那么该文件通常存储在/var/run目录中。锁文件的名字通常是name.pid
   2. 若守护进程支持配置选项，那么配置文件通常存放在/etc目录中。配置文件的名字通常是name.conf
   3. 守护进程可用命令行启动，但通常它们是由系统初始化脚本之一(/etc/rc*或/etc/init.d/*)启动的。
      如果在守护进程终止时，应当自动重新启动它，则我们可以在/etc/inittab中为该守护进程包括respawn记录项，
      这样，init就将重新启动该守护进程。
   4. 若一个守护进程有一个配置文件。一般启动时读取，之后不再读取。如果修改了配置文件，需要重启守护进程。
      为避免这种麻烦，某些守护进程将捕获SIGHUP信号，当它们接收到该信号时，重新读取配置文件。
** 客户进程-服务器进程模型
   守护进程通常用作服务器进程。
   在服务器进程中调用fork然后exec另一个程序向客户进程提供服务是很常见的。
   这些服务器进程通常管理着多个文件描述符：通信端点、配置文件、日志文件和类似的文件。
   最坏的情况下，让子进程的这些文件描述符保持打开状态会导致安全问题--被执行的程序可能有一些恶意行为。
   解决此问题的一个简单办法是对所有被执行程序不需要的文件描述符设置执行时关闭(close-on-exec)标志。
* 第十四章 高级I/O
** 非阻塞I/O
   <2016-06-08 Wed>
   非阻塞I/O使我们可以发出open、read和write这样的I/O操作，并使这些操作不会永远阻塞。
   如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞。
   对于一个给定的描述符，有两种为其指定非阻塞I/O的方法。
   1. 如果调用open获得描述符，则可指定O_NONBLOCK标志。
   2. 对于已经打开的一个描述符，则可调用fcntl,由该函数打开O_NONBLOCK文件状态标志。·
** 记录锁
   记录锁(record locking)的功能是：当第一个进程正在读或修改文件的某个部分时，使用
   记录锁可以阻止其他进程修改同一文件区。一个更适合的术语可能是字节范围锁，因为它
   锁定的只是文件中的一个区域(也可能是整个文件)
*** 历史
flock,lockf, fcntl都支持记录锁
flock只支持针对整个文件加锁。
*** fcntl记录锁
    #include <fcntl.h>
    int fcntl(int fd, int cmd, ... /* struct flock *flockptr */);
    
    对于记录锁，cmd是F_GETLK、F_SETLK或F_SETLKW。第三个参数(flockptr)是一个指向flock结构的指针。
    struct flock{
        short l_type; /* F_RDLCK, F_WRLCK, or F_UNLCK */
        short l_whence; /* SEEK_SET, SEEK_CUR, or SEEK_END */
        off_t l_start; /* offset in bytes, relative to l_whence */
        off_t l_len; /* length, in bytes; 0 means lock to EOF */
        pid_t l_pid; /* returned with F_GETTLK */
    };
    关于加锁或解锁区域的说明还有注意下列几项规则。
    * 指定区域起始偏移量的两个元素与lseek函数中最后两个参数类似。
    * 锁可以在当前文件尾端处开始或者越过尾端处开始，但是不能在文件起始位置之前开始。
    * 如若l_len为0，则表示锁的范围可以扩展到最大可能偏移量。这就意味着不管向该文件中追加了多少数据，
      它们都可以处于锁的范围内，而且起始位置可以是文件中的任意一个位置。
    * 为了对整个文件加锁，我们设置l_start和l_whence指向文件的起始位置，并且指定长度(l_len)为0。

      
    有2种类型的锁：共享读锁(l_type为L_RDLCK)和独占性写锁(L_WRLCK)。
    | \                | 读锁 | 写锁 |
    |------------------+------+------|
    | 无锁             | 允许 | 允许 |
    | 有一把或多把读锁 | 允许 | 拒绝 |
    | 有一把写锁       | 拒绝 | 拒绝 |
    以上兼容性表格适用于不同的进程提出的锁请求，并不适用于单个进程提出的多个锁请求。
    如果一个进程对一个文件区间已经有一把锁，后来该进程又企图在同一文件区再加一把锁，那么新锁
    将替换已有锁。
    
    另读锁时，该描述符必须是读打开。加写锁时，该描述符必须是写打开。
    fcntl函数的3种命令:
    1. F_GETLK 判断由flockptr所描述的锁是否会被另外一把锁所排斥(阻塞)。如果存在一把锁，
       它阻止创建由flockptr所描述的锁，则该现有锁的信息将重写flockptr指向的信息。如果不存在
       这种情况，则除了装饰l_type设置为F_UNLCK之外，flockptr所指向结构中的其他信息保持不变。
    2. F_SETLK 设置由flockptr所描述的锁。如果我们试图获得一把读锁或写锁，而兼容性规则阻止系统
       给我们这把锁，那么fcntl会立即出错返回，此时errno设置为EACCESS或EAGAIN。
       此命令也用来清除由flockptr指向的锁(l_type为F_UNLCK)
    3. F_SETLKW 这个命令是F_SETLK的阻塞版本(w = wait)。如果所请示的读锁或写锁因另一个进程当前已经
       对所请求区域的某部分进行了加锁而不能被授予，那么调用进程会被置为休眠。如果请求创建的锁已经可用
       或者休眠由信号中断，则该进程被唤醒。
       
       
    在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。
*** 锁的隐含继承和释放
    关于记录锁的自动继承和释放有3条规则。
    1. 锁与进程和文件两者相关联。进程终止时，它所建立的锁全部释放。无论一个描述符何时关闭，该进程通过
       这一描述符引用的文件上的所有锁都会释放。
    2. 由fork产生的子进程不继承父进程所设置的锁。
    3. 在执行exec后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置了执行时关闭标志，
       那么当作为exec的一部分关闭该文件描述符时，将释放相应文件的所有锁。
*** FreeBSD的实现
    lockf指针是记录在v节点表项上。这解释了上述的第一条规则
    进程表项->文件表项->v节点表项->i节点
*** 在文件尾端加锁
    以下代码序列:
    writew_lock(d, 0, SEEK_END,0);
    write(fd, buf,1);
    un_lock(fd, 0, SEEK_END);//这里其实有问题，它没有完全解锁，新写的一个字节其实是保持锁住状态的。
    //正确的方式 是un_lock(fd, 0, SEEK_END,-1)
    write(fd, buf,1);
*** 建议性锁和强制性锁
    建议性锁并不能阻止对数据库文件有写权限的任何其他进程写这个数据库文件。
    强制性锁会让内核检查每一个open、read和write,验证调用进程是否违背了正在访问的文件上的某一把锁。强制性锁
    有时也称为强迫方式锁。
    
    对一个特定文件打开其设置组ID位、关闭其组执行位便开启了对该文件的强制性锁机制。因为当组执行位关闭时，设置组ID位不再有意义
    所以SVR3的设计者借用两者的这种组合来指定对一个文件的锁是强制性的而非建议性的。

    如果一个进程试图读(read)或写(write)一个强制性锁起作用的文件，而欲读、写的部分又由其他进程加上了锁，此时会发生什么呢？
    这取决于3个方面的因素:操作类型，其他进程持有的锁的类型 以及read或write的描述符是阻塞还是非阻塞的。
    | 其它进程在该区域上持有的现有锁的类型 | 阻塞描述符 |       | 非阻塞描述符 |        |
    |                                      | read       | write | read         | write  |
    | 读锁                                 | 允许       | 阻塞  | 允许         | EAGAIN |
    | 写锁                                 | 阻塞       | 阻塞  | EAGAIN       | EAGAIN |
    需要警惕: 强制性锁可以避免。譬如按ed编辑器的方式，先把内容写到临时文件，删除原文件，再重命名临时文件。强制性锁机制对unlink函数没有影响。
** STREAMS
** I/O多路转换
    如果必须从两个描述符读，我们不能在任一个描述符上进行阻塞读(read),否则可能会因为阻塞在一个描述符的读操作
    上而导致另一个描述符即使有数据也无法处理。
    解决办法:
    1. 将一个进程变成两个进程。每个进程处理一条数据通路。进程终止处理比较复杂。
    2. 用一个进程中的两个线程。要求处理两个线程之间的同步问题。
    3. 使用非阻塞I/O读取。轮询着读2个描述符。问题是浪费CPU时间，同时很难确定每次循环后要等多长时间再执行下一轮循环。
    4. 异步I/O。利用这种技术，进程告诉内核:当描述符准备好可以进行I/O时，用一个信号通知它。
       兼容性有问题。受限的信号SIGPOLL和SIGIO。
       对进程来说，信号只有一个，但是有两个描述符，无法确认是哪个描述符可读。仍然需要轮询。
    5. 推荐技术：I/O多路转接。为了使用这种技术，先构造一张我们感兴趣的描述符列表，然后调用一个函数，
       直到这些描述符中的一个已准备好进行I/O时，该函数才返回。poll、pselect和select这3个函数使我们能够
       执行I/O多路转接。在从这些函数返回时，进程会被告知哪些描述符已准备好可以进行I/O。
*** 函数select和pselect
    传给select的参数告诉内核:
    * 我们所关心的描述符。
    * 对于每个描述符我们所关心的条件(是否想从一个给定的描述符读，是否想写一个给定的描述符，是否关心一个给定的描述符的异常条件)
    * 愿意等待多长时间(可以永远等待、等待一个固定的时间或者根本不等待)。
      

    从select返回时，内核告诉我们：
    * 已准备好的描述符的总数量。
    * 对于读、写或异常这3个条件中的每一个，哪些描述符已准备好。
      
    使用这种返回信息，就可调用相应的I/O函数，并且确知该函数不会阻塞。
    #include <sys/select.h>
    int select(int maxfdp1, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict exceptfds,struct timeval *restrict tvptr);

    对于fd_set数据类型，唯一可以进行的处理是：分配一个这种类型的变量，将这种类型的一个变量值赋给同类型的另一个变量，
    或对这种类型的变量使用下列4个函数中的一个。
    #include <sys/select.h>
    int FD_ISSET(int fd, fd_set *fdset);
    void FD_CLR(int fd, fd_set *fdset);
    void FD_SET(int fd, fd_set *fdset);
    void FD_ZERO(fd_set *fdset);

    
    如果select的中间3个参数都是NULL,则select提供了比sleep更精确的定时器(精确到微秒)
    select的第一个参数maxfdp1的意思是"最大文件描述符编号值加1".通过指定我们所关注的
    最大描述符，内核就只需在此范围内寻找打开的位。
    
    一个描述符阻塞与否并不影响select是否阻塞。

    如果在一个描述符上碰到了文件尾端，则select会认为该描述符是可读的。然后调用read,
    它返回0,这是UNIX系统指示到达文件尾端的方法。
*** 函数poll
    poll函数类似于select,但是程序员接口有所不同。虽然poll函数是System V引入进来支持SREAMS子系统的，但是poll函数可用于
    任何类型的文件描述符。
    #include <poll.h>
    int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);
                           返回值：准备就绪的描述符数目；若超时，返回0；若出错，返回-1；
    
    struct pollfd{
        int fd;
        short events;/* events of interest on fd*/
        short revents;/* events that occurred on
    }
      
    | 标志名     | 输入至events? | 从revents得到结果? | 说明                                                                 |
    |------------+---------------+--------------------+----------------------------------------------------------------------|
    | POLLIN     | *             | *                  | 可以不阻塞地读高优先级数据以外的数据(等效于POLLRDNORM 或 POLLRDBAND) |
    | POLLRDNORM | *             | *                  | 可以不阻塞地读普通数据                                               |
    | POLLRDBAND | *             | *                  | 可以不阻塞地读优先级数据                                             |
    | POLLPRI    | *             | *                  | 可以不阻塞地读高优先级数据                                           |
    |------------+---------------+--------------------+----------------------------------------------------------------------|
    | POLLOUT    | *             | *                  | 可以不阻塞地写普通数据                                               |
    | POLLWRNORM | *             | *                  | 与POLLOUT相同                                                        |
    | POLLWRBAND | *             | *                  | 可以不阻塞地写优先级数据                                             |
    |------------+---------------+--------------------+----------------------------------------------------------------------|
    | POLLERR    |               | *                  | 已出错                                                               |
    | POLLHUP    |               | *                  | 已挂断                                                               |
    | POLLNVAL   |               | *                  | 描述符没有引用一个打开文件                                                        |
    理解文件尾端和挂断之间的区别很重要，如果我们正在从终端输入数据，并键入文件结束符，
    那么就会打开POLLIN, 于是我们就可以读文件结束指示。revents中的POLLHUP没有打开。
    如果正在读调制解调器，并且电话线已挂断，我们将接到POLLHUP通知。
    
    由于历史原因，select和poll在中断时并不会自动重启。但是在SVR4上，如果指定了SA_RESTART,
    那么select和poll也是自动重启的 ，为了阻止这一点，可以使用signal_intr函数。
** 异步I/O
*** 系统V异步I/O
*** BSD异步I/O
    由BSD和System V派生的所有系统都提供了某种形式的异步I/O,使用一个信号（在System V中是SIGPOLL,
    在BSD中是SIGIO)通知进程，对某个描述符所关心的某个事情已经发生了。
    这种形式的异步I/O是受限的：它们并不能用在所有的文件类型上，而且只能使用一个信号。
    
    使用POSIX异步I/O接口,会带来下列麻烦:
    * 每个异步操作有3处可能产生错误的地方：
      一处在操作提交的部分，一处在操作本身的结果，还有一处在用于决定异步操作状态的函数中。
    * 与POSIX异步I/O接口的的传统方法相比，它们本身涉及大量的额外设置和处理规则。
    * 从错误中恢复可能会比较困难。
*** System V异步I/O
    异步I/O是STREAMS系统的一部分，它只对STREAMS设备和STREAMS管道起作用。System V的异步I/O信号是SIGPOLL.
    为了对一个STREAMS设备启动异步I/O,需要调用ioctl,将它的第二个参数设置成I_SETSIG。
*** BSD异步I/O
    在BSD派生的系统中，异步I/O是信号SIGIO和SIGURG的组合。SIGIO是通用异步I/O信号，SIGURG则只用来通知进程网络连接上的带外数据已经到达。
    为了接收SIGIO信号，需要执行以下3步
    1. 调用signal或sigaction为SIGIO信号建立信号处理程序。
    2. 以命令F_SETOWN调用fcntl来设置进程ID或进程组ID,用于接收对于该描述符的信号。
    3. 以命令F_SETFL调用fcntl设置O_ASYNC文件状态标志。使在该描述符上可以进行异步I/O。
*** POSIX异步I/O
    这些异步I/O接口使用AIO控制块来描述I/O操作。aiocb结构定义了AIO控制块。该结构至少包括下面这些字段:
    struct aiocb {
        int aio_fildes;/* file descriptor */
        off_t aio_offset; /* file offset for I/O */
        volatile void *aio_buf; /* buffer for I/O */
        size_t aio_nbytes; /* number of bytes to transfer */
        int aio_reqprio; /* priority */
        struct sigevent aio_sigevent; /* signal information */
        int aio_lio_opcode; /* operation for list I/O */
    };
    注意：异步I/O操作必须显式地指定偏移量。异步I/O接口并不影响由操作系统维护的文件偏移量。只要不在同一个进程里
    把异步I/O函数和传统的I/O函数混在一起用在同一文件上，就不会导致什么问题。同时值得注意的是，如果使用异步I/O
    接口向一个以追加模式(使用O_APPEND)打开的文件中写入数据，AIO控制块中的aio_offset字段会被系统忽略。
    
    aio_sigevent字段控制在I/O事件完成后，如何通知应用程序。使用sigevent结构描述
    struct sigevent {
        int sigev_notify;/* notify type, SIGEV_NONE,不通知；SIGEV_SIGNAL,产生由sigev_signo字段指定的信号
                                          SIGEV_THREAD,由sigev_notify_function字段指定的函数被调用。*/
        int sigev_signo;
        union sigval sigev_value;/* notify argument */
        void (*sigev_notify_function)(union sigval);
        pthread_attr_t *sigev_notify_attributes;/* notify attrs */
    }
    
    在进行异步I/O之前需要先初始化AIO控制块，调用aio_read函数来进行异步读操作，或调用aio_write函数来进行异步写操作。
    #include <aio.h>
    int aio_read(struct aiocb *aiocb);
    int aio_write(struct aiocb *aiocb);
    I/O操作在等待时，必须注意确保AIO控制块和数据库缓冲区保持稳定；它们下面对应的内存必须始终是合法的，
    除非I/O操作完成，否则不能被复用。
    
    要想强制所有等待中的异步操作不等待而写入持久化的存储中，可以设立一个AIO控制块并调用aio_fsync函数。
    #include <aio.h>
    int aio_fsync(int op, struct aiocb *aiocb);
    
    为了获知一个异步读、写或者同步操作的完成状态，需要调用aio_error函数。
    #include <aio.h>
    int aio_error(const struct aiocb *aiocb);
    返回值说明：
    * 0 异步操作完成。需要调用aio_return函数获取操作返回值。
    * -1 对aio_error调用失败。这种情况下,errno会告诉我们为什么。
    * EINPROGRESS  异步读、写或同步操作仍在等待。
    * 其他情况 其他任何返回值是相关的异步操作失败返回的错误码。
      
    #include <aio.h>
    ssize_t aio_return(const struct aiocb *aiocb);
    直到异步操作完成之前，都需要小心不要调用aio_return函数。操作完成之前的结果是未定义的。
    还需要小心对每个异步操作只调用一次aio_return。一旦调用了该函数，操作系统就可以释放掉
    包含了I/O操作返回值的记录。
   
    执行I/O操作时，如果还有其他事务要处理而不想被I/O操作阻塞，就可以使用异步I/O。然而，
    如果在完成了所有事务时，还有异步操作未完成时，可以调用aio_suspend函数来阻塞进程，
    直到操作完成。
    #include <aio.h>
    int aio_suspend(const struct aiocb *const list[], int nent, const struct timespec *timeout);
    返回的情况：中断、超时、有任一I/O操作完成。
    
    当我们不想再完成的等待中的异步I/O操作时，可以尝试使用aio_cancel函数来取消它们。
    #include <aio.h>
    int aio_cancel(int fd, struct aiocb *aiocb);
    返回值有4种：
    * AIO_ALLDONE 所有操作在尝试取消它们之前已经完成。
    * AIO_CANCELED 所有要求的操作已被取消。
    * AIO_NOTCANCELED 至少有一个要求的操作没有被取消。
    * -1 对aio_cancel的调用失败，错误码将被存储在errno中。
   
    lio_listio,提交一系统由一个AIO控制块列表描述的I/O请求。
    #include <aio.h>
    int lio_listio(int mode, struct aiocb *restrict const list[], int nent, struct sigevent *restrict sigev);
    
** readv和writev函数
   readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数
   称为散步读(scatter read)和聚集写(gather write)。
   #include <sys/uio.h>
   ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
   ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
   这两个函数的第二个参数是指向iovec结构数组的一个指针：
   struct iovec {
       void *iov_base;
       size_t iov_len;
   }
   iov数组中的元素数由iovcnt指定，其最大值受限于IOV_MAX。
** readn和writen函数
   管道、FIFO以及某些设备(特别是终端和网络)有下列两种性质。
   1. 一次read操作所返回的数据可能少于所要求的数据，即使还没达到文件尾端也可能是这样。
      这不是一个错误，应当继续读该设备。
   2. 一次write操作的返回值也可能少于指定输出的字节数。这可能是由某个因素造成的，
      例如，内核输出缓冲区变满。这也不是错误，应当继续写余下的数据。
     

   readn和writen只是按需多次调用read和write直至读、写了N字节数据。
   #include "apue.h"
   ssize_t readn(int fd, void *buf, size_t nbytes);
   ssize_t writen(int fd, void *buf, size_t nbytes);

** 存储映射I/O
   存储映射I/O(memory-mapped I/O)能将一个磁盘文件映射到存储空间中的一个缓冲区上，
   于是，当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，
   相应字节就自动写入文件。这样，就可以在不使用read和write的情况下执行I/O.
   
   为了使用这种功能，应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由mmap函数
   实现的。
   #include <sys/mman.h>
   void *mmap(void *addr, size_t len, int prot, int flag, int fd, off_t off);
   
   addr参数用于指定映射存储区的起始地址。通常将其设置为0，这表示由系统选择该映射区的起始
   地址。此函数的返回值是该映射区的起始地址。
   
   fd参数是指定要被映射文件的描述符。在文件映射到地址空间之前，必须先打开该文件。
   len参数是映射的字节数，off是要映射字节在文件中的起始偏移量。
   prot参数指定了映射存储区的保护要求，
   | prot       | 说明           |
   |------------+----------------|
   | PROT_READ  | 映射区可读     |
   | PROT_WRITE | 映射区可写     |
   | PROT_EXEC  | 映射区可执行   |
   | PROT_NONE  | 映射区不可访问 |
   对指定映射存储区的保护要求不能超过文件open模式访问权限。 
   
   flag参数:
   MAP_FIXED 返回值必须等于addr。不利于移植性。一般设置为0
   MAP_SHARED 这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件。
   MAP_PRIVATE 本标志说明，对映射区的存储操作导致创建该映射文件的一个私有副本。
   
   与映射区相关的信号有SIGSEGV和SIGBUS。信号SIGSEGV通常用于指示进程试图访问对它不可用的存储区。
   如果映射存储区被mmap指定成了只读的，那么进程试图将数据存入这个映射存储区的时候，也会产生此信号。
   如果映射区的某个部分在访问时已不存在，则产生SIGBUS信号。
  
   调用mprotect可以更改一个现有映射的权限。
   #include <sys/mman.h>
   int mprotect(void *addr, size_t len, int prot);
   需要注意，地址参数addr的值必须是系统页长的整数倍。
   
   如果共享映射中的页已修改，那么可以调用msync将该页冲洗到被映射的文件中 。
   msync函数类似于fsync，但作用于存储映射区。
   #include <sys/mman.h>
   int msync(void *addr, size_t len, int flags);
   
   当进程终止时，会自动解除存储映射区的映射，或者直接调用munmap函数也可以解除映射区。
   关闭映射存储区时使用的文件描述符并不解除映射区。
   #include <sys/mman.h>
   int munmap(void *addr, size_t len);
   munmap并不影响被映射的对象，也就是说，调用munmap并不会使映射区的内容写到磁盘文件上。
   对于MAP_SHARED区磁盘文件的更新，会在我们将数据写到存储映射区后的某个时刻，
   按内核虚拟存储算法自动进行。在存储区解除映射后，对MAP_PRIVATE存储区的修改会被丢弃。
   
* 第十五章 进程间通信
** 引言
  <2016-06-16 Thu> 
   | IPC类型        | SUS     | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
   |----------------+---------+-------------+-------------+-----------------+------------|
   | 半双工管道     | *       | (全)        | *           | *               | (全)       |
   | FIFO           | *       | *           | *           | *               | *          |
   |----------------+---------+-------------+-------------+-----------------+------------|
   | 全双工管道     | 允许    | *、UDS      | UDS         | UDS             | *、UDS     |
   | 命名全双工管道 | 废弃的  | UDS         | UDS         | UDS             | *、UDS     |
   |----------------+---------+-------------+-------------+-----------------+------------|
   | XSI 消息队列   | XSI     | *           | *           | *               | *          |
   | XSI信号量      | XSI     | *           | *           | *               | *          |
   | XSI共享存储    | XSI     | *           | *           | *               | *          |
   |----------------+---------+-------------+-------------+-----------------+------------|
   | 消息队列(实时) | MSG选项 | *           | *           | *               | *          |
   | 信号量         | *       | *           | *           | *               | *          |
   | 共享存储(实时) | SHM选项 | *           | *           | *               | *          |
   |----------------+---------+-------------+-------------+-----------------+------------|
   | 套接字         | *       | *           | *           | *               | *          |
   | STREAMS        | 废弃的  |             |             |                 | *          |
   
   前10个是用于本地进程间通信。后2个用于不同主机上两个进程之间IPC通信。
** 管道
   管道是UNIX系统IPC的最古老的形式，所有UNIX系统都提供此种通信机制。管道有以下两种局限性。
   1. 历史上，它们是半双工的(即数据只能在一个方向上流动)。现在，某些系统提供全双工管道，
      但是为了最佳的可移植性，我们决不应预先假定系统支持全双工管道。
   2. 管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程
      调用fork之后，这个管道就能在父进程和子进程之间使用了。
      

   FIFO没有第二种局限性，UNIX域套接字没有这两种局限性。
   尽管有这两种局限性，半双工管道仍是最常用的IPC形式。
   管道是通过调用pipe函数创建的。
   #include <unistd.h>
   int pipe(int fd[2]);
   经由参数fd返回两个文件描述符:fd[0]为读而打开,fd[1]为写而打开。fd[1]的输出是fd[0]的输入
   
   fstat函数对管道的每一端都返回一个FIFO类型的文件描述符。可以用S_ISFIFO宏来测试管道。
   当管道的一端被关闭后，下列两条规则起作用。
   1. 当读(read)一个写端已被关闭的管道时，在所有数据都被读取后，read返回0,表示文件结束。
   2. 如果写(write)一个读端已被关闭的管道，则产生信号SIGPIPE。如果忽略该信号或者捕捉该信号
      并从其处理程序返回，则write返回-1,errno设置为EPIPE。
      
      
   在写管道(或FIFO)时，常量PIPE_BUF规定了内核的管道缓冲区大小。如果对管道调用write，而且要求写的
   字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或FIFO)的write操作交叉进行。如果超过，则会。
   
** 函数popen和pclose
   常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其输入端面发送数据，为此，标准I/O库提供了
   两个函数popen和pclose。这两个函数实现的操作是：创建一个管道，fork一个子进程，关闭未使用的管道端，
   执行一个shell运行命令，然后等待命令终止。
   #include <stdio.h>
   FILE *popen(const char *cmdstring, const char *type);
   int pclose(FILE *fp);
   
   函数popen先执行fork,然后调用exec执行cmdstring,并且返回一个标准I/O文件指针。如果type是"r",则文件指针连接到cmdstring的标准输出。
   如果type是"w",则文件指针连接到cmdstring的标准输出。
    
** 协同进程
   当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了协同进程。
   
   popen只提供连接到另一个进程的标准输入或标准输出的一个单向管道，而协同进程则有连接到另一个进程的两个单向管道：
   一个接到其标准输入，另一个则来自其标准输出。
   我们想将数据写到其标准输入，经其处理后，再从其标准输出读取数据。
** FIFO
** XSI IPC
*** 标志符和键
*** 权限结构
*** 结构限制
*** 优点和缺点
** 消息队列
** 信号量
** 共享存储
* 第十六章 网络IPC:套接字
  ** 复习 **　
* 第十七章 高级进程间通信
* 第十八章 终端I/O
* 第十九章 伪终端
* 第二十章 数据库函数库
   **需要复习**
* 第二十一章 与网络打印机通信
   **需要复习**
